//! Experimental FFT library with an emphasis on runtime performance.
//! This currently only works on powers of two. The FFTs are autogenerated
//! with a procedural macro which hand unrolls all the loops with inlined
//! functions to allow the compiler to maximize the SIMD throughput available
//! on the given CPU.
//!
//! This library will use all SIMD features your CPU has available including AVX512,
//! assuming you compile with those features (`RUSTFLAGS="-C target-cpu=native" cargo build`).
//!
//! This library implements FFTs for both `f32` and `f64` for the following sizes:
//!
//! ```no_compile
//! 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
//! ```
//!
//! If a larger FFT size is needed, just clone the repo and add the needed
//! sizes to the top of `crates\monarch-derive\src\lib.rs` and larger FFTs
//! will be generated. However, this comes at the cost of a longer compile time.
//!
//! ```
//! use monarch_butterfly::*;
//! use num_complex::Complex;
//!
//! let input: Vec<_> = (0..8).map(|i| Complex::new(i as f32, 0.0)).collect();
//! let output_slice = fft8(&input);
//! let output_vec = fft8(input);
//! ```

#![allow(clippy::excessive_precision)]

use num_complex::Complex;
use num_traits::{Float, FloatConst};

const SQRT_3: f64 = 1.7320508075688772;
const SQRT_3_DIV_2: f64 = SQRT_3 / 2.0;

monarch_derive::generate_powers_of_two!();

fn _compute_twiddle<T: Float + FloatConst>(index: usize, fft_len: usize) -> Complex<T> {
    let constant = T::from(-2.0).unwrap() * T::PI() / T::from(fft_len).unwrap();
    // index * -2PI / fft_len
    let angle = constant * T::from(index).unwrap();

    Complex::new(angle.cos(), angle.sin())
}

#[inline]
pub fn fft3<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 3] {
    let n = 3;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle: Complex<T> = Complex::new(T::from(-0.5).unwrap(), -T::from(SQRT_3_DIV_2).unwrap());

    let xp = x[1] + x[2];
    let xn = x[1] - x[2];
    let sum = x[0] + xp;

    let temp_a = x[0]
        + Complex {
            re: twiddle.re * xp.re,
            im: twiddle.re * xp.im,
        };
    let temp_b = Complex {
        re: -twiddle.im * xn.im,
        im: twiddle.im * xn.re,
    };

    [sum, temp_a + temp_b, temp_a - temp_b]
}

#[inline]
pub fn fft5<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 5] {
    let n = 5;
    let x = input.as_ref();
    assert_eq!(n, x.len());
    let twiddle1: Complex<T> = Complex::new(
        T::from(0.30901699437494745).unwrap(),
        T::from(-0.95105651629515353).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.80901699437494734).unwrap(),
        T::from(-0.58778525229247325).unwrap(),
    );

    let x14p = x[1] + x[4];
    let x14n = x[1] - x[4];
    let x23p = x[2] + x[3];
    let x23n = x[2] - x[3];
    let sum = x[0] + x14p + x23p;
    let b14re_a = x[0].re + twiddle1.re * x14p.re + twiddle2.re * x23p.re;
    let b14re_b = twiddle1.im * x14n.im + twiddle2.im * x23n.im;
    let b23re_a = x[0].re + twiddle2.re * x14p.re + twiddle1.re * x23p.re;
    let b23re_b = twiddle2.im * x14n.im + -twiddle1.im * x23n.im;

    let b14im_a = x[0].im + twiddle1.re * x14p.im + twiddle2.re * x23p.im;
    let b14im_b = twiddle1.im * x14n.re + twiddle2.im * x23n.re;
    let b23im_a = x[0].im + twiddle2.re * x14p.im + twiddle1.re * x23p.im;
    let b23im_b = twiddle2.im * x14n.re + -twiddle1.im * x23n.re;

    let out1re = b14re_a - b14re_b;
    let out1im = b14im_a + b14im_b;
    let out2re = b23re_a - b23re_b;
    let out2im = b23im_a + b23im_b;
    let out3re = b23re_a + b23re_b;
    let out3im = b23im_a - b23im_b;
    let out4re = b14re_a + b14re_b;
    let out4im = b14im_a - b14im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
    ]
}

#[inline]
pub fn fft6<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 6] {
    let n = 6;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let left = fft3([x[0], x[2], x[4]]);
    let right = fft3([x[3], x[5], x[1]]);

    let row1 = fft2([left[0], right[0]]);
    let row2 = fft2([left[1], right[1]]);
    let row3 = fft2([left[2], right[2]]);

    [row1[0], row2[1], row3[0], row1[1], row2[0], row3[1]]
}

#[inline]
pub fn fft7<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 7] {
    let n = 7;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.62348980185873359).unwrap(),
        T::from(-0.78183148246802969).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.22252093395631434).unwrap(),
        T::from(-0.97492791218182361).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(-0.90096886790241903).unwrap(),
        T::from(-0.43388373911755823).unwrap(),
    );

    let x16p = x[1] + x[6];
    let x16n = x[1] - x[6];
    let x25p = x[2] + x[5];
    let x25n = x[2] - x[5];
    let x34p = x[3] + x[4];
    let x34n = x[3] - x[4];
    let sum = x[0] + x16p + x25p + x34p;

    let x16re_a = x[0].re + twiddle1.re * x16p.re + twiddle2.re * x25p.re + twiddle3.re * x34p.re;
    let x16re_b = twiddle1.im * x16n.im + twiddle2.im * x25n.im + twiddle3.im * x34n.im;
    let x25re_a = x[0].re + twiddle1.re * x34p.re + twiddle2.re * x16p.re + twiddle3.re * x25p.re;
    let x25re_b = -twiddle1.im * x34n.im + twiddle2.im * x16n.im - twiddle3.im * x25n.im;
    let x34re_a = x[0].re + twiddle1.re * x25p.re + twiddle2.re * x34p.re + twiddle3.re * x16p.re;
    let x34re_b = -twiddle1.im * x25n.im + twiddle2.im * x34n.im + twiddle3.im * x16n.im;
    let x16im_a = x[0].im + twiddle1.re * x16p.im + twiddle2.re * x25p.im + twiddle3.re * x34p.im;
    let x16im_b = twiddle1.im * x16n.re + twiddle2.im * x25n.re + twiddle3.im * x34n.re;
    let x25im_a = x[0].im + twiddle1.re * x34p.im + twiddle2.re * x16p.im + twiddle3.re * x25p.im;
    let x25im_b = -twiddle1.im * x34n.re + twiddle2.im * x16n.re - twiddle3.im * x25n.re;
    let x34im_a = x[0].im + twiddle1.re * x25p.im + twiddle2.re * x34p.im + twiddle3.re * x16p.im;
    let x34im_b = twiddle1.im * x25n.re - twiddle2.im * x34n.re - twiddle3.im * x16n.re;

    let out1re = x16re_a - x16re_b;
    let out1im = x16im_a + x16im_b;
    let out2re = x25re_a - x25re_b;
    let out2im = x25im_a + x25im_b;
    let out3re = x34re_a - x34re_b;
    let out3im = x34im_a - x34im_b;
    let out4re = x34re_a + x34re_b;
    let out4im = x34im_a + x34im_b;
    let out5re = x25re_a + x25re_b;
    let out5im = x25im_a - x25im_b;
    let out6re = x16re_a + x16re_b;
    let out6im = x16im_a - x16im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
    ]
}

#[inline]
pub fn fft9<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 9] {
    let n = 9;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.76604444311897801).unwrap(),
        T::from(-0.64278760968653925).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.17364817766693041).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.93969262078590832).unwrap(),
        T::from(-0.34202014332566888).unwrap(),
    );

    let first = fft3([x[0], x[3], x[6]]);
    let second = fft3([x[1], x[4], x[7]]);
    let third = fft3([x[2], x[5], x[8]]);

    let row0 = fft3([first[0], second[0], third[0]]);
    let row1 = fft3([first[1], second[1] * twiddle1, third[1] * twiddle2]);
    let row2 = fft3([first[2], second[2] * twiddle2, third[2] * twiddle4]);

    [
        row0[0], row1[0], row2[0], row0[1], row1[1], row2[1], row0[2], row1[2], row2[2],
    ]
}

#[inline]
pub fn fft10<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 10] {
    let n = 10;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft2([x[0], x[5]]);
    let row1 = fft2([x[2], x[7]]);
    let row2 = fft2([x[4], x[9]]);
    let row3 = fft2([x[6], x[1]]);
    let row4 = fft2([x[8], x[3]]);

    let col0 = fft5([row0[0], row1[0], row2[0], row3[0], row4[0]]);
    let col1 = fft5([row0[1], row1[1], row2[1], row3[1], row4[1]]);

    [
        col0[0], col1[1], col0[2], col1[3], col0[4], col1[0], col0[1], col1[2], col0[3], col1[4],
    ]
}

#[cfg(test)]
mod tests {
    use num_complex::Complex;

    use crate::*;

    fn butterfly(x: Vec<Complex<f32>>) -> Vec<Complex<f32>> {
        let n = x.len();
        if n <= 1 {
            x
        } else {
            let even: Vec<_> = butterfly(x.iter().step_by(2).cloned().collect());
            let odd: Vec<_> = butterfly(x.iter().skip(1).step_by(2).cloned().collect());

            let t: Vec<_> = (0..(n / 2))
                .map(|k| {
                    Complex::exp(
                        -2.0 * Complex::<f32>::i() * std::f32::consts::PI * k as f32 / n as f32,
                    ) * odd[k]
                })
                .collect();

            [
                (0..(n / 2)).map(|k| even[k] + t[k]).collect::<Vec<_>>(),
                (0..(n / 2)).map(|k| even[k] - t[k]).collect::<Vec<_>>(),
            ]
            .concat()
        }
    }
    #[test]
    fn test_butterfly_2() {
        assert_eq!(
            fft2([Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)]).to_vec(),
            butterfly(vec![Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)])
        );
    }

    #[test]
    fn test_fft3() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(3);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
        ];

        let monarch = fft3(&buf);

        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
    }

    #[test]
    fn test_fft5() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(5);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
        ];

        let monarch = fft5(&buf);

        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
        assert!((monarch[3].re - buf[3].re).abs() < 0.0000001);
        assert!((monarch[3].im - buf[3].im).abs() < 0.0000001);
        assert!((monarch[4].re - buf[4].re).abs() < 0.0000001);
        assert!((monarch[4].im - buf[4].im).abs() < 0.0000001);
    }

    #[test]
    fn test_fft6() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(6);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
        ];

        let monarch = fft6(&buf);
        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
        assert!((monarch[3].re - buf[3].re).abs() < 0.0000001);
        assert!((monarch[3].im - buf[3].im).abs() < 0.0000001);
        assert!((monarch[4].re - buf[4].re).abs() < 0.0000001);
        assert!((monarch[4].im - buf[4].im).abs() < 0.0000001);
        assert!((monarch[5].re - buf[5].re).abs() < 0.0000001);
        assert!((monarch[5].im - buf[5].im).abs() < 0.0000001);
    }

    #[test]
    fn test_fft7() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(7);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
        ];

        let monarch = fft7(&buf);
        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
        assert!((monarch[3].re - buf[3].re).abs() < 0.0000001);
        assert!((monarch[3].im - buf[3].im).abs() < 0.0000001);
        assert!((monarch[4].re - buf[4].re).abs() < 0.0000001);
        assert!((monarch[4].im - buf[4].im).abs() < 0.0000001);
        assert!((monarch[5].re - buf[5].re).abs() < 0.0000001);
        assert!((monarch[5].im - buf[5].im).abs() < 0.0000001);
        assert!((monarch[6].re - buf[6].re).abs() < 0.0000001);
        assert!((monarch[6].im - buf[6].im).abs() < 0.0000001);
    }

    #[test]
    fn test_8() {
        let a = butterfly((1..9).map(|i| Complex::new(i as f32, 0.0)).collect());
        assert_eq!(a[0], Complex::new(36.0, 0.0));
        assert_eq!(a[6], Complex::new(-4.0, -4.0));
    }

    #[test]
    fn test_fft9() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(9);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
        ];

        let monarch = fft9(&buf);
        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
        assert!((monarch[3].re - buf[3].re).abs() < 0.0000001);
        assert!((monarch[3].im - buf[3].im).abs() < 0.0000001);
        assert!((monarch[4].re - buf[4].re).abs() < 0.0000001);
        assert!((monarch[4].im - buf[4].im).abs() < 0.0000001);
        assert!((monarch[5].re - buf[5].re).abs() < 0.0000001);
        assert!((monarch[5].im - buf[5].im).abs() < 0.0000001);
        assert!((monarch[6].re - buf[6].re).abs() < 0.0000001);
        assert!((monarch[6].im - buf[6].im).abs() < 0.0000001);
        assert!((monarch[7].re - buf[7].re).abs() < 0.0000001);
        assert!((monarch[7].im - buf[7].im).abs() < 0.0000001);
        assert!((monarch[8].re - buf[8].re).abs() < 0.0000001);
        assert!((monarch[8].im - buf[8].im).abs() < 0.0000001);
    }

    #[test]
    fn test_fft10() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(10);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
            Complex::new(9.0, 0.0),
        ];

        let monarch = fft10(&buf);
        plan.process(&mut buf);

        assert_eq!(monarch[0], buf[0]);
        assert!((monarch[1].re - buf[1].re).abs() < 0.0000001);
        assert!((monarch[1].im - buf[1].im).abs() < 0.0000001);
        assert!((monarch[2].re - buf[2].re).abs() < 0.0000001);
        assert!((monarch[2].im - buf[2].im).abs() < 0.0000001);
        assert!((monarch[3].re - buf[3].re).abs() < 0.0000001);
        assert!((monarch[3].im - buf[3].im).abs() < 0.0000001);
        assert!((monarch[4].re - buf[4].re).abs() < 0.0000001);
        assert!((monarch[4].im - buf[4].im).abs() < 0.0000001);
        assert!((monarch[5].re - buf[5].re).abs() < 0.0000001);
        assert!((monarch[5].im - buf[5].im).abs() < 0.0000001);
        assert!((monarch[6].re - buf[6].re).abs() < 0.0000001);
        assert!((monarch[6].im - buf[6].im).abs() < 0.0000001);
        assert!((monarch[7].re - buf[7].re).abs() < 0.0000001);
        assert!((monarch[7].im - buf[7].im).abs() < 0.0000001);
        assert!((monarch[8].re - buf[8].re).abs() < 0.0000001);
        assert!((monarch[8].im - buf[8].im).abs() < 0.0000001);
        assert!((monarch[9].re - buf[9].re).abs() < 0.0000001);
        assert!((monarch[9].im - buf[9].im).abs() < 0.0000001);
    }

    #[test]
    fn test_butterfly_4() {
        assert_eq!(
            fft4([
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0)
            ])
            .to_vec(),
            butterfly(vec![
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0),
            ])
        );
    }

    #[test]
    fn test_butterfly_1024() {
        let v: Vec<_> = (0..1024)
            .map(|i: i32| Complex::new(i as f32, i as f32))
            .collect();
        let a: [Complex<f32>; 1024] = (0..1024)
            .map(|i| Complex::new(i as f32, i as f32))
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();

        let ba = fft1024(a);
        let bv = butterfly(v);

        assert_eq!(&ba, &*bv);
    }
}
