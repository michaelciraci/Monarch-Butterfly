//! Experimental FFT library with an emphasis on runtime performance.
//! This currently only works on powers of two. The FFTs are autogenerated
//! with a procedural macro which hand unrolls all the loops with inlined
//! functions to allow the compiler to maximize the SIMD throughput available
//! on the given CPU.
//!
//! This library will use all SIMD features your CPU has available including AVX512,
//! assuming you compile with those features (`RUSTFLAGS="-C target-cpu=native" cargo build`).
//!
//! This library implements FFTs for both `f32` and `f64` for the following sizes:
//!
//! ```no_compile
//! 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
//! ```
//!
//! If a larger FFT size is needed, just clone the repo and add the needed
//! sizes to the top of `crates\monarch-derive\src\lib.rs` and larger FFTs
//! will be generated. However, this comes at the cost of a longer compile time.
//!
//! ```
//! use monarch_butterfly::*;
//! use num_complex::Complex;
//!
//! let input: Vec<_> = (0..8).map(|i| Complex::new(i as f32, 0.0)).collect();
//! let output_slice = fft8(&input);
//! let output_vec = fft8(input);
//! ```

#![allow(clippy::excessive_precision)]

use num_complex::Complex;
use num_traits::{Float, FloatConst};

const SQRT_3: f64 = 1.7320508075688772;
const SQRT_3_DIV_2: f64 = SQRT_3 / 2.0;

monarch_derive::generate_powers_of_two!();

fn _compute_twiddle<T: Float + FloatConst>(index: usize, fft_len: usize) -> Complex<T> {
    let constant = T::from(-2.0).unwrap() * T::PI() / T::from(fft_len).unwrap();
    // index * -2PI / fft_len
    let angle = constant * T::from(index).unwrap();

    Complex::new(angle.cos(), angle.sin())
}

#[inline]
pub fn fft3<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 3] {
    let n = 3;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle: Complex<T> = Complex::new(T::from(-0.5).unwrap(), -T::from(SQRT_3_DIV_2).unwrap());

    let xp = x[1] + x[2];
    let xn = x[1] - x[2];
    let sum = x[0] + xp;

    let temp_a = x[0]
        + Complex {
            re: twiddle.re * xp.re,
            im: twiddle.re * xp.im,
        };
    let temp_b = Complex {
        re: -twiddle.im * xn.im,
        im: twiddle.im * xn.re,
    };

    [sum, temp_a + temp_b, temp_a - temp_b]
}

#[inline]
pub fn fft5<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 5] {
    let n = 5;
    let x = input.as_ref();
    assert_eq!(n, x.len());
    let twiddle1: Complex<T> = Complex::new(
        T::from(0.30901699437494745).unwrap(),
        T::from(-0.95105651629515353).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.80901699437494734).unwrap(),
        T::from(-0.58778525229247325).unwrap(),
    );

    let x14p = x[1] + x[4];
    let x14n = x[1] - x[4];
    let x23p = x[2] + x[3];
    let x23n = x[2] - x[3];
    let sum = x[0] + x14p + x23p;
    let b14re_a = x[0].re + twiddle1.re * x14p.re + twiddle2.re * x23p.re;
    let b14re_b = twiddle1.im * x14n.im + twiddle2.im * x23n.im;
    let b23re_a = x[0].re + twiddle2.re * x14p.re + twiddle1.re * x23p.re;
    let b23re_b = twiddle2.im * x14n.im + -twiddle1.im * x23n.im;

    let b14im_a = x[0].im + twiddle1.re * x14p.im + twiddle2.re * x23p.im;
    let b14im_b = twiddle1.im * x14n.re + twiddle2.im * x23n.re;
    let b23im_a = x[0].im + twiddle2.re * x14p.im + twiddle1.re * x23p.im;
    let b23im_b = twiddle2.im * x14n.re + -twiddle1.im * x23n.re;

    let out1re = b14re_a - b14re_b;
    let out1im = b14im_a + b14im_b;
    let out2re = b23re_a - b23re_b;
    let out2im = b23im_a + b23im_b;
    let out3re = b23re_a + b23re_b;
    let out3im = b23im_a - b23im_b;
    let out4re = b14re_a + b14re_b;
    let out4im = b14im_a - b14im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
    ]
}

#[inline]
pub fn fft6<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 6] {
    let n = 6;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let left = fft3([x[0], x[2], x[4]]);
    let right = fft3([x[3], x[5], x[1]]);

    let row1 = fft2([left[0], right[0]]);
    let row2 = fft2([left[1], right[1]]);
    let row3 = fft2([left[2], right[2]]);

    [row1[0], row2[1], row3[0], row1[1], row2[0], row3[1]]
}

#[inline]
pub fn fft7<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 7] {
    let n = 7;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.62348980185873359).unwrap(),
        T::from(-0.78183148246802969).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.22252093395631434).unwrap(),
        T::from(-0.97492791218182361).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(-0.90096886790241903).unwrap(),
        T::from(-0.43388373911755823).unwrap(),
    );

    let x16p = x[1] + x[6];
    let x16n = x[1] - x[6];
    let x25p = x[2] + x[5];
    let x25n = x[2] - x[5];
    let x34p = x[3] + x[4];
    let x34n = x[3] - x[4];
    let sum = x[0] + x16p + x25p + x34p;

    let x16re_a = x[0].re + twiddle1.re * x16p.re + twiddle2.re * x25p.re + twiddle3.re * x34p.re;
    let x16re_b = twiddle1.im * x16n.im + twiddle2.im * x25n.im + twiddle3.im * x34n.im;
    let x25re_a = x[0].re + twiddle1.re * x34p.re + twiddle2.re * x16p.re + twiddle3.re * x25p.re;
    let x25re_b = -twiddle1.im * x34n.im + twiddle2.im * x16n.im - twiddle3.im * x25n.im;
    let x34re_a = x[0].re + twiddle1.re * x25p.re + twiddle2.re * x34p.re + twiddle3.re * x16p.re;
    let x34re_b = -twiddle1.im * x25n.im + twiddle2.im * x34n.im + twiddle3.im * x16n.im;
    let x16im_a = x[0].im + twiddle1.re * x16p.im + twiddle2.re * x25p.im + twiddle3.re * x34p.im;
    let x16im_b = twiddle1.im * x16n.re + twiddle2.im * x25n.re + twiddle3.im * x34n.re;
    let x25im_a = x[0].im + twiddle1.re * x34p.im + twiddle2.re * x16p.im + twiddle3.re * x25p.im;
    let x25im_b = -twiddle1.im * x34n.re + twiddle2.im * x16n.re - twiddle3.im * x25n.re;
    let x34im_a = x[0].im + twiddle1.re * x25p.im + twiddle2.re * x34p.im + twiddle3.re * x16p.im;
    let x34im_b = twiddle1.im * x25n.re - twiddle2.im * x34n.re - twiddle3.im * x16n.re;

    let out1re = x16re_a - x16re_b;
    let out1im = x16im_a + x16im_b;
    let out2re = x25re_a - x25re_b;
    let out2im = x25im_a + x25im_b;
    let out3re = x34re_a - x34re_b;
    let out3im = x34im_a - x34im_b;
    let out4re = x34re_a + x34re_b;
    let out4im = x34im_a + x34im_b;
    let out5re = x25re_a + x25re_b;
    let out5im = x25im_a - x25im_b;
    let out6re = x16re_a + x16re_b;
    let out6im = x16im_a - x16im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
    ]
}

#[inline]
pub fn fft9<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 9] {
    let n = 9;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.76604444311897801).unwrap(),
        T::from(-0.64278760968653925).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.17364817766693041).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.93969262078590832).unwrap(),
        T::from(-0.34202014332566888).unwrap(),
    );

    let first = fft3([x[0], x[3], x[6]]);
    let second = fft3([x[1], x[4], x[7]]);
    let third = fft3([x[2], x[5], x[8]]);

    let row0 = fft3([first[0], second[0], third[0]]);
    let row1 = fft3([first[1], second[1] * twiddle1, third[1] * twiddle2]);
    let row2 = fft3([first[2], second[2] * twiddle2, third[2] * twiddle4]);

    [
        row0[0], row1[0], row2[0], row0[1], row1[1], row2[1], row0[2], row1[2], row2[2],
    ]
}

#[inline]
pub fn fft10<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 10] {
    let n = 10;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft2([x[0], x[5]]);
    let row1 = fft2([x[2], x[7]]);
    let row2 = fft2([x[4], x[9]]);
    let row3 = fft2([x[6], x[1]]);
    let row4 = fft2([x[8], x[3]]);

    let col0 = fft5([row0[0], row1[0], row2[0], row3[0], row4[0]]);
    let col1 = fft5([row0[1], row1[1], row2[1], row3[1], row4[1]]);

    [
        col0[0], col1[1], col0[2], col1[3], col0[4], col1[0], col0[1], col1[2], col0[3], col1[4],
    ]
}

#[inline]
pub fn fft11<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 11] {
    let n = 11;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.84125353283118121).unwrap(),
        T::from(-0.54064081745559756).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.41541501300188644).unwrap(),
        T::from(-0.90963199535451833).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(-0.142314838273285).unwrap(),
        T::from(-0.9898214418809328).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.65486073394528499).unwrap(),
        T::from(-0.75574957435425838).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.95949297361449736).unwrap(),
        T::from(-0.28173255684142962).unwrap(),
    );

    let x110p = x[1] + x[10];
    let x110n = x[1] - x[10];
    let x29p = x[2] + x[9];
    let x29n = x[2] - x[9];
    let x38p = x[3] + x[8];
    let x38n = x[3] - x[8];
    let x47p = x[4] + x[7];
    let x47n = x[4] - x[7];
    let x56p = x[5] + x[6];
    let x56n = x[5] - x[6];
    let sum = x[0] + x110p + x29p + x38p + x47p + x56p;
    let b110re_a = x[0].re
        + twiddle1.re * x110p.re
        + twiddle2.re * x29p.re
        + twiddle3.re * x38p.re
        + twiddle4.re * x47p.re
        + twiddle5.re * x56p.re;
    let b110re_b = twiddle1.im * x110n.im
        + twiddle2.im * x29n.im
        + twiddle3.im * x38n.im
        + twiddle4.im * x47n.im
        + twiddle5.im * x56n.im;
    let b29re_a = x[0].re
        + twiddle2.re * x110p.re
        + twiddle4.re * x29p.re
        + twiddle5.re * x38p.re
        + twiddle3.re * x47p.re
        + twiddle1.re * x56p.re;
    let b29re_b = twiddle2.im * x110n.im
        + twiddle4.im * x29n.im
        + -twiddle5.im * x38n.im
        + -twiddle3.im * x47n.im
        + -twiddle1.im * x56n.im;
    let b38re_a = x[0].re
        + twiddle3.re * x110p.re
        + twiddle5.re * x29p.re
        + twiddle2.re * x38p.re
        + twiddle1.re * x47p.re
        + twiddle4.re * x56p.re;
    let b38re_b = twiddle3.im * x110n.im
        + -twiddle5.im * x29n.im
        + -twiddle2.im * x38n.im
        + twiddle1.im * x47n.im
        + twiddle4.im * x56n.im;
    let b47re_a = x[0].re
        + twiddle4.re * x110p.re
        + twiddle3.re * x29p.re
        + twiddle1.re * x38p.re
        + twiddle5.re * x47p.re
        + twiddle2.re * x56p.re;
    let b47re_b = twiddle4.im * x110n.im
        + -twiddle3.im * x29n.im
        + twiddle1.im * x38n.im
        + twiddle5.im * x47n.im
        + -twiddle2.im * x56n.im;
    let b56re_a = x[0].re
        + twiddle5.re * x110p.re
        + twiddle1.re * x29p.re
        + twiddle4.re * x38p.re
        + twiddle2.re * x47p.re
        + twiddle3.re * x56p.re;
    let b56re_b = twiddle5.im * x110n.im
        + -twiddle1.im * x29n.im
        + twiddle4.im * x38n.im
        + -twiddle2.im * x47n.im
        + twiddle3.im * x56n.im;

    let b110im_a = x[0].im
        + twiddle1.re * x110p.im
        + twiddle2.re * x29p.im
        + twiddle3.re * x38p.im
        + twiddle4.re * x47p.im
        + twiddle5.re * x56p.im;
    let b110im_b = twiddle1.im * x110n.re
        + twiddle2.im * x29n.re
        + twiddle3.im * x38n.re
        + twiddle4.im * x47n.re
        + twiddle5.im * x56n.re;
    let b29im_a = x[0].im
        + twiddle2.re * x110p.im
        + twiddle4.re * x29p.im
        + twiddle5.re * x38p.im
        + twiddle3.re * x47p.im
        + twiddle1.re * x56p.im;
    let b29im_b = twiddle2.im * x110n.re
        + twiddle4.im * x29n.re
        + -twiddle5.im * x38n.re
        + -twiddle3.im * x47n.re
        + -twiddle1.im * x56n.re;
    let b38im_a = x[0].im
        + twiddle3.re * x110p.im
        + twiddle5.re * x29p.im
        + twiddle2.re * x38p.im
        + twiddle1.re * x47p.im
        + twiddle4.re * x56p.im;
    let b38im_b = twiddle3.im * x110n.re
        + -twiddle5.im * x29n.re
        + -twiddle2.im * x38n.re
        + twiddle1.im * x47n.re
        + twiddle4.im * x56n.re;
    let b47im_a = x[0].im
        + twiddle4.re * x110p.im
        + twiddle3.re * x29p.im
        + twiddle1.re * x38p.im
        + twiddle5.re * x47p.im
        + twiddle2.re * x56p.im;
    let b47im_b = twiddle4.im * x110n.re
        + -twiddle3.im * x29n.re
        + twiddle1.im * x38n.re
        + twiddle5.im * x47n.re
        + -twiddle2.im * x56n.re;
    let b56im_a = x[0].im
        + twiddle5.re * x110p.im
        + twiddle1.re * x29p.im
        + twiddle4.re * x38p.im
        + twiddle2.re * x47p.im
        + twiddle3.re * x56p.im;
    let b56im_b = twiddle5.im * x110n.re
        + -twiddle1.im * x29n.re
        + twiddle4.im * x38n.re
        + -twiddle2.im * x47n.re
        + twiddle3.im * x56n.re;

    let out1re = b110re_a - b110re_b;
    let out1im = b110im_a + b110im_b;
    let out2re = b29re_a - b29re_b;
    let out2im = b29im_a + b29im_b;
    let out3re = b38re_a - b38re_b;
    let out3im = b38im_a + b38im_b;
    let out4re = b47re_a - b47re_b;
    let out4im = b47im_a + b47im_b;
    let out5re = b56re_a - b56re_b;
    let out5im = b56im_a + b56im_b;
    let out6re = b56re_a + b56re_b;
    let out6im = b56im_a - b56im_b;
    let out7re = b47re_a + b47re_b;
    let out7im = b47im_a - b47im_b;
    let out8re = b38re_a + b38re_b;
    let out8im = b38im_a - b38im_b;
    let out9re = b29re_a + b29re_b;
    let out9im = b29im_a - b29im_b;
    let out10re = b110re_a + b110re_b;
    let out10im = b110im_a - b110im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
    ]
}

#[inline]
pub fn fft12<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 12] {
    let n = 12;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let column0 = fft4([x[0], x[3], x[6], x[9]]);
    let column1 = fft4([x[4], x[7], x[10], x[1]]);
    let column2 = fft4([x[8], x[11], x[2], x[5]]);

    let row0 = fft3([column0[0], column1[0], column2[0]]);
    let row1 = fft3([column0[1], column1[1], column2[1]]);
    let row2 = fft3([column0[2], column1[2], column2[2]]);
    let row3 = fft3([column0[3], column1[3], column2[3]]);

    [
        row0[0], row1[1], row2[2], row3[0], row0[1], row1[2], row2[0], row3[1], row0[2], row1[0],
        row2[1], row3[2],
    ]
}

#[inline]
pub fn fft13<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 13] {
    let n = 13;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.88545602565320991).unwrap(),
        T::from(-0.46472317204376851).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.56806474673115592).unwrap(),
        T::from(-0.82298386589365635).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(0.12053668025532323).unwrap(),
        T::from(-0.99270887409805397).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.35460488704253545).unwrap(),
        T::from(-0.93501624268541483).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.74851074817110086).unwrap(),
        T::from(-0.66312265824079553).unwrap(),
    );
    let twiddle6: Complex<T> = Complex::new(
        T::from(-0.9709418174260519).unwrap(),
        T::from(-0.2393156642875581).unwrap(),
    );

    let x112p = x[1] + x[12];
    let x112n = x[1] - x[12];
    let x211p = x[2] + x[11];
    let x211n = x[2] - x[11];
    let x310p = x[3] + x[10];
    let x310n = x[3] - x[10];
    let x49p = x[4] + x[9];
    let x49n = x[4] - x[9];
    let x58p = x[5] + x[8];
    let x58n = x[5] - x[8];
    let x67p = x[6] + x[7];
    let x67n = x[6] - x[7];
    let sum = x[0] + x112p + x211p + x310p + x49p + x58p + x67p;
    let b112re_a = x[0].re
        + twiddle1.re * x112p.re
        + twiddle2.re * x211p.re
        + twiddle3.re * x310p.re
        + twiddle4.re * x49p.re
        + twiddle5.re * x58p.re
        + twiddle6.re * x67p.re;
    let b112re_b = twiddle1.im * x112n.im
        + twiddle2.im * x211n.im
        + twiddle3.im * x310n.im
        + twiddle4.im * x49n.im
        + twiddle5.im * x58n.im
        + twiddle6.im * x67n.im;
    let b211re_a = x[0].re
        + twiddle2.re * x112p.re
        + twiddle4.re * x211p.re
        + twiddle6.re * x310p.re
        + twiddle5.re * x49p.re
        + twiddle3.re * x58p.re
        + twiddle1.re * x67p.re;
    let b211re_b = twiddle2.im * x112n.im
        + twiddle4.im * x211n.im
        + twiddle6.im * x310n.im
        + -twiddle5.im * x49n.im
        + -twiddle3.im * x58n.im
        + -twiddle1.im * x67n.im;
    let b310re_a = x[0].re
        + twiddle3.re * x112p.re
        + twiddle6.re * x211p.re
        + twiddle4.re * x310p.re
        + twiddle1.re * x49p.re
        + twiddle2.re * x58p.re
        + twiddle5.re * x67p.re;
    let b310re_b = twiddle3.im * x112n.im
        + twiddle6.im * x211n.im
        + -twiddle4.im * x310n.im
        + -twiddle1.im * x49n.im
        + twiddle2.im * x58n.im
        + twiddle5.im * x67n.im;
    let b49re_a = x[0].re
        + twiddle4.re * x112p.re
        + twiddle5.re * x211p.re
        + twiddle1.re * x310p.re
        + twiddle3.re * x49p.re
        + twiddle6.re * x58p.re
        + twiddle2.re * x67p.re;
    let b49re_b = twiddle4.im * x112n.im
        + -twiddle5.im * x211n.im
        + -twiddle1.im * x310n.im
        + twiddle3.im * x49n.im
        + -twiddle6.im * x58n.im
        + -twiddle2.im * x67n.im;
    let b58re_a = x[0].re
        + twiddle5.re * x112p.re
        + twiddle3.re * x211p.re
        + twiddle2.re * x310p.re
        + twiddle6.re * x49p.re
        + twiddle1.re * x58p.re
        + twiddle4.re * x67p.re;
    let b58re_b = twiddle5.im * x112n.im
        + -twiddle3.im * x211n.im
        + twiddle2.im * x310n.im
        + -twiddle6.im * x49n.im
        + -twiddle1.im * x58n.im
        + twiddle4.im * x67n.im;
    let b67re_a = x[0].re
        + twiddle6.re * x112p.re
        + twiddle1.re * x211p.re
        + twiddle5.re * x310p.re
        + twiddle2.re * x49p.re
        + twiddle4.re * x58p.re
        + twiddle3.re * x67p.re;
    let b67re_b = twiddle6.im * x112n.im
        + -twiddle1.im * x211n.im
        + twiddle5.im * x310n.im
        + -twiddle2.im * x49n.im
        + twiddle4.im * x58n.im
        + -twiddle3.im * x67n.im;

    let b112im_a = x[0].im
        + twiddle1.re * x112p.im
        + twiddle2.re * x211p.im
        + twiddle3.re * x310p.im
        + twiddle4.re * x49p.im
        + twiddle5.re * x58p.im
        + twiddle6.re * x67p.im;
    let b112im_b = twiddle1.im * x112n.re
        + twiddle2.im * x211n.re
        + twiddle3.im * x310n.re
        + twiddle4.im * x49n.re
        + twiddle5.im * x58n.re
        + twiddle6.im * x67n.re;
    let b211im_a = x[0].im
        + twiddle2.re * x112p.im
        + twiddle4.re * x211p.im
        + twiddle6.re * x310p.im
        + twiddle5.re * x49p.im
        + twiddle3.re * x58p.im
        + twiddle1.re * x67p.im;
    let b211im_b = twiddle2.im * x112n.re
        + twiddle4.im * x211n.re
        + twiddle6.im * x310n.re
        + -twiddle5.im * x49n.re
        + -twiddle3.im * x58n.re
        + -twiddle1.im * x67n.re;
    let b310im_a = x[0].im
        + twiddle3.re * x112p.im
        + twiddle6.re * x211p.im
        + twiddle4.re * x310p.im
        + twiddle1.re * x49p.im
        + twiddle2.re * x58p.im
        + twiddle5.re * x67p.im;
    let b310im_b = twiddle3.im * x112n.re
        + twiddle6.im * x211n.re
        + -twiddle4.im * x310n.re
        + -twiddle1.im * x49n.re
        + twiddle2.im * x58n.re
        + twiddle5.im * x67n.re;
    let b49im_a = x[0].im
        + twiddle4.re * x112p.im
        + twiddle5.re * x211p.im
        + twiddle1.re * x310p.im
        + twiddle3.re * x49p.im
        + twiddle6.re * x58p.im
        + twiddle2.re * x67p.im;
    let b49im_b = twiddle4.im * x112n.re
        + -twiddle5.im * x211n.re
        + -twiddle1.im * x310n.re
        + twiddle3.im * x49n.re
        + -twiddle6.im * x58n.re
        + -twiddle2.im * x67n.re;
    let b58im_a = x[0].im
        + twiddle5.re * x112p.im
        + twiddle3.re * x211p.im
        + twiddle2.re * x310p.im
        + twiddle6.re * x49p.im
        + twiddle1.re * x58p.im
        + twiddle4.re * x67p.im;
    let b58im_b = twiddle5.im * x112n.re
        + -twiddle3.im * x211n.re
        + twiddle2.im * x310n.re
        + -twiddle6.im * x49n.re
        + -twiddle1.im * x58n.re
        + twiddle4.im * x67n.re;
    let b67im_a = x[0].im
        + twiddle6.re * x112p.im
        + twiddle1.re * x211p.im
        + twiddle5.re * x310p.im
        + twiddle2.re * x49p.im
        + twiddle4.re * x58p.im
        + twiddle3.re * x67p.im;
    let b67im_b = twiddle6.im * x112n.re
        + -twiddle1.im * x211n.re
        + twiddle5.im * x310n.re
        + -twiddle2.im * x49n.re
        + twiddle4.im * x58n.re
        + -twiddle3.im * x67n.re;

    let out1re = b112re_a - b112re_b;
    let out1im = b112im_a + b112im_b;
    let out2re = b211re_a - b211re_b;
    let out2im = b211im_a + b211im_b;
    let out3re = b310re_a - b310re_b;
    let out3im = b310im_a + b310im_b;
    let out4re = b49re_a - b49re_b;
    let out4im = b49im_a + b49im_b;
    let out5re = b58re_a - b58re_b;
    let out5im = b58im_a + b58im_b;
    let out6re = b67re_a - b67re_b;
    let out6im = b67im_a + b67im_b;
    let out7re = b67re_a + b67re_b;
    let out7im = b67im_a - b67im_b;
    let out8re = b58re_a + b58re_b;
    let out8im = b58im_a - b58im_b;
    let out9re = b49re_a + b49re_b;
    let out9im = b49im_a - b49im_b;
    let out10re = b310re_a + b310re_b;
    let out10im = b310im_a - b310im_b;
    let out11re = b211re_a + b211re_b;
    let out11im = b211im_a - b211im_b;
    let out12re = b112re_a + b112re_b;
    let out12im = b112im_a - b112im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
        Complex::new(out11re, out11im),
        Complex::new(out12re, out12im),
    ]
}

#[inline]
pub fn fft14<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 14] {
    let n = 14;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft2([x[0], x[7]]);
    let row1 = fft2([x[2], x[9]]);
    let row2 = fft2([x[4], x[11]]);
    let row3 = fft2([x[6], x[13]]);
    let row4 = fft2([x[8], x[1]]);
    let row5 = fft2([x[10], x[3]]);
    let row6 = fft2([x[12], x[5]]);

    let col0 = fft7([
        row0[0], row1[0], row2[0], row3[0], row4[0], row5[0], row6[0],
    ]);
    let col1 = fft7([
        row0[1], row1[1], row2[1], row3[1], row4[1], row5[1], row6[1],
    ]);

    [
        col0[0], col1[1], col0[2], col1[3], col0[4], col1[5], col0[6], col1[0], col0[1], col1[2],
        col0[3], col1[4], col0[5], col1[6],
    ]
}

#[cfg(test)]
mod tests {
    use num_complex::Complex;

    use crate::*;

    macro_rules! assert_slice_equal {
        ($lhs:expr,$rhs:expr) => {
            assert_slice_equal!($lhs, $rhs, 0.0001);
        };
        ($lhs:expr,$rhs:expr,$tol:expr) => {
            assert_eq!($lhs.len(), $rhs.len());
            for idx in 0..($lhs.len()) {
                assert!(
                    ($lhs[idx].re - $rhs[idx].re).abs() < $tol,
                    "index {} does not match: ({} - {}).abs() < {}",
                    idx,
                    $lhs[idx].re,
                    $rhs[idx].re,
                    $tol
                );
                assert!(
                    ($lhs[idx].im - $rhs[idx].im).abs() < $tol,
                    "index {} does not match: ({} - {}).abs() < {}",
                    idx,
                    $lhs[idx].im,
                    $rhs[idx].im,
                    $tol
                );
            }
        };
    }

    fn butterfly(x: Vec<Complex<f32>>) -> Vec<Complex<f32>> {
        let n = x.len();
        if n <= 1 {
            x
        } else {
            let even: Vec<_> = butterfly(x.iter().step_by(2).cloned().collect());
            let odd: Vec<_> = butterfly(x.iter().skip(1).step_by(2).cloned().collect());

            let t: Vec<_> = (0..(n / 2))
                .map(|k| {
                    Complex::exp(
                        -2.0 * Complex::<f32>::i() * std::f32::consts::PI * k as f32 / n as f32,
                    ) * odd[k]
                })
                .collect();

            [
                (0..(n / 2)).map(|k| even[k] + t[k]).collect::<Vec<_>>(),
                (0..(n / 2)).map(|k| even[k] - t[k]).collect::<Vec<_>>(),
            ]
            .concat()
        }
    }

    #[test]
    fn test_butterfly_2() {
        assert_eq!(
            fft2([Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)]).to_vec(),
            butterfly(vec![Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)])
        );
    }

    #[test]
    fn test_fft3() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(3);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
        ];

        let monarch = fft3(&buf);

        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_butterfly_4() {
        assert_eq!(
            fft4([
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0)
            ])
            .to_vec(),
            butterfly(vec![
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0),
            ])
        );
    }

    #[test]
    fn test_fft5() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(5);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
        ];

        let monarch = fft5(&buf);

        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft6() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(6);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
        ];

        let monarch = fft6(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft7() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(7);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
        ];

        let monarch = fft7(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_8() {
        let a = butterfly((1..9).map(|i| Complex::new(i as f32, 0.0)).collect());
        assert_eq!(a[0], Complex::new(36.0, 0.0));
        assert_eq!(a[6], Complex::new(-4.0, -4.0));
    }

    #[test]
    fn test_fft9() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(9);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
        ];

        let monarch = fft9(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft10() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(10);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
            Complex::new(9.0, 0.0),
        ];

        let monarch = fft10(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft11() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(11);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
            Complex::new(9.0, 0.0),
            Complex::new(10.0, 0.0),
        ];

        let monarch = fft11(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft12() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(12);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
            Complex::new(9.0, 0.0),
            Complex::new(10.0, 0.0),
            Complex::new(11.0, 0.0),
        ];

        let monarch = fft12(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft13() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(13);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
            Complex::new(3.0, 0.0),
            Complex::new(4.0, 0.0),
            Complex::new(5.0, 0.0),
            Complex::new(6.0, 0.0),
            Complex::new(7.0, 0.0),
            Complex::new(8.0, 0.0),
            Complex::new(9.0, 0.0),
            Complex::new(10.0, 0.0),
            Complex::new(11.0, 0.0),
            Complex::new(12.0, 0.0),
        ];

        let monarch = fft13(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_butterfly_1024() {
        let v: Vec<_> = (0..1024)
            .map(|i: i32| Complex::new(i as f32, i as f32))
            .collect();
        let a: [Complex<f32>; 1024] = (0..1024)
            .map(|i| Complex::new(i as f32, i as f32))
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();

        let ba = fft1024(a);
        let bv = butterfly(v);

        assert_slice_equal!(ba, bv, 0.001);
    }
}
