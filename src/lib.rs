//! Experimental FFT library with an emphasis on runtime performance.
//! This currently only works on powers of two. The FFTs are autogenerated
//! with a procedural macro which hand unrolls all the loops with inlined
//! functions to allow the compiler to maximize the SIMD throughput available
//! on the given CPU.
//!
//! This library will use all SIMD features your CPU has available including AVX512,
//! assuming you compile with those features (`RUSTFLAGS="-C target-cpu=native" cargo build`).
//!
//! This library implements FFTs for both `f32` and `f64` for the following sizes:
//!
//! ```no_compile
//! 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
//! ```
//!
//! If a larger FFT size is needed, just clone the repo and add the needed
//! sizes to the top of `crates\monarch-derive\src\lib.rs` and larger FFTs
//! will be generated. However, this comes at the cost of a longer compile time.
//!
//! ```
//! use monarch_butterfly::*;
//! use num_complex::Complex;
//!
//! let input: Vec<_> = (0..8).map(|i| Complex::new(i as f32, 0.0)).collect();
//! let output_slice = fft8(&input);
//! let output_vec = fft8(input);
//! ```

#![allow(clippy::excessive_precision)]

use num_complex::Complex;
use num_traits::{Float, FloatConst};

const SQRT_3: f64 = 1.7320508075688772;
const SQRT_3_DIV_2: f64 = SQRT_3 / 2.0;

monarch_derive::generate_powers_of_two!();

fn _compute_twiddle<T: Float + FloatConst>(index: usize, fft_len: usize) -> Complex<T> {
    let constant = T::from(-2.0).unwrap() * T::PI() / T::from(fft_len).unwrap();
    // index * -2PI / fft_len
    let angle = constant * T::from(index).unwrap();

    Complex::new(angle.cos(), angle.sin())
}

#[inline]
pub fn fft3<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 3] {
    let n = 3;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle: Complex<T> = Complex::new(T::from(-0.5).unwrap(), -T::from(SQRT_3_DIV_2).unwrap());

    let xp = x[1] + x[2];
    let xn = x[1] - x[2];
    let sum = x[0] + xp;

    let temp_a = x[0]
        + Complex {
            re: twiddle.re * xp.re,
            im: twiddle.re * xp.im,
        };
    let temp_b = Complex {
        re: -twiddle.im * xn.im,
        im: twiddle.im * xn.re,
    };

    [sum, temp_a + temp_b, temp_a - temp_b]
}

#[inline]
pub fn fft5<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 5] {
    let n = 5;
    let x = input.as_ref();
    assert_eq!(n, x.len());
    let twiddle1: Complex<T> = Complex::new(
        T::from(0.30901699437494745).unwrap(),
        T::from(-0.95105651629515353).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.80901699437494734).unwrap(),
        T::from(-0.58778525229247325).unwrap(),
    );

    let x14p = x[1] + x[4];
    let x14n = x[1] - x[4];
    let x23p = x[2] + x[3];
    let x23n = x[2] - x[3];
    let sum = x[0] + x14p + x23p;
    let b14re_a = x[0].re + twiddle1.re * x14p.re + twiddle2.re * x23p.re;
    let b14re_b = twiddle1.im * x14n.im + twiddle2.im * x23n.im;
    let b23re_a = x[0].re + twiddle2.re * x14p.re + twiddle1.re * x23p.re;
    let b23re_b = twiddle2.im * x14n.im + -twiddle1.im * x23n.im;

    let b14im_a = x[0].im + twiddle1.re * x14p.im + twiddle2.re * x23p.im;
    let b14im_b = twiddle1.im * x14n.re + twiddle2.im * x23n.re;
    let b23im_a = x[0].im + twiddle2.re * x14p.im + twiddle1.re * x23p.im;
    let b23im_b = twiddle2.im * x14n.re + -twiddle1.im * x23n.re;

    let out1re = b14re_a - b14re_b;
    let out1im = b14im_a + b14im_b;
    let out2re = b23re_a - b23re_b;
    let out2im = b23im_a + b23im_b;
    let out3re = b23re_a + b23re_b;
    let out3im = b23im_a - b23im_b;
    let out4re = b14re_a + b14re_b;
    let out4im = b14im_a - b14im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
    ]
}

#[inline]
pub fn fft6<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 6] {
    let n = 6;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let left = fft3([x[0], x[2], x[4]]);
    let right = fft3([x[3], x[5], x[1]]);

    let row1 = fft2([left[0], right[0]]);
    let row2 = fft2([left[1], right[1]]);
    let row3 = fft2([left[2], right[2]]);

    [row1[0], row2[1], row3[0], row1[1], row2[0], row3[1]]
}

#[inline]
pub fn fft7<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 7] {
    let n = 7;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.62348980185873359).unwrap(),
        T::from(-0.78183148246802969).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(-0.22252093395631434).unwrap(),
        T::from(-0.97492791218182361).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(-0.90096886790241903).unwrap(),
        T::from(-0.43388373911755823).unwrap(),
    );

    let x16p = x[1] + x[6];
    let x16n = x[1] - x[6];
    let x25p = x[2] + x[5];
    let x25n = x[2] - x[5];
    let x34p = x[3] + x[4];
    let x34n = x[3] - x[4];
    let sum = x[0] + x16p + x25p + x34p;

    let x16re_a = x[0].re + twiddle1.re * x16p.re + twiddle2.re * x25p.re + twiddle3.re * x34p.re;
    let x16re_b = twiddle1.im * x16n.im + twiddle2.im * x25n.im + twiddle3.im * x34n.im;
    let x25re_a = x[0].re + twiddle1.re * x34p.re + twiddle2.re * x16p.re + twiddle3.re * x25p.re;
    let x25re_b = -twiddle1.im * x34n.im + twiddle2.im * x16n.im - twiddle3.im * x25n.im;
    let x34re_a = x[0].re + twiddle1.re * x25p.re + twiddle2.re * x34p.re + twiddle3.re * x16p.re;
    let x34re_b = -twiddle1.im * x25n.im + twiddle2.im * x34n.im + twiddle3.im * x16n.im;
    let x16im_a = x[0].im + twiddle1.re * x16p.im + twiddle2.re * x25p.im + twiddle3.re * x34p.im;
    let x16im_b = twiddle1.im * x16n.re + twiddle2.im * x25n.re + twiddle3.im * x34n.re;
    let x25im_a = x[0].im + twiddle1.re * x34p.im + twiddle2.re * x16p.im + twiddle3.re * x25p.im;
    let x25im_b = -twiddle1.im * x34n.re + twiddle2.im * x16n.re - twiddle3.im * x25n.re;
    let x34im_a = x[0].im + twiddle1.re * x25p.im + twiddle2.re * x34p.im + twiddle3.re * x16p.im;
    let x34im_b = twiddle1.im * x25n.re - twiddle2.im * x34n.re - twiddle3.im * x16n.re;

    let out1re = x16re_a - x16re_b;
    let out1im = x16im_a + x16im_b;
    let out2re = x25re_a - x25re_b;
    let out2im = x25im_a + x25im_b;
    let out3re = x34re_a - x34re_b;
    let out3im = x34im_a - x34im_b;
    let out4re = x34re_a + x34re_b;
    let out4im = x34im_a + x34im_b;
    let out5re = x25re_a + x25re_b;
    let out5im = x25im_a - x25im_b;
    let out6re = x16re_a + x16re_b;
    let out6im = x16im_a - x16im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
    ]
}

#[inline]
pub fn fft9<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 9] {
    let n = 9;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.76604444311897801).unwrap(),
        T::from(-0.64278760968653925).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.17364817766693041).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.93969262078590832).unwrap(),
        T::from(-0.34202014332566888).unwrap(),
    );

    let first = fft3([x[0], x[3], x[6]]);
    let second = fft3([x[1], x[4], x[7]]);
    let third = fft3([x[2], x[5], x[8]]);

    let row0 = fft3([first[0], second[0], third[0]]);
    let row1 = fft3([first[1], second[1] * twiddle1, third[1] * twiddle2]);
    let row2 = fft3([first[2], second[2] * twiddle2, third[2] * twiddle4]);

    [
        row0[0], row1[0], row2[0], row0[1], row1[1], row2[1], row0[2], row1[2], row2[2],
    ]
}

#[inline]
pub fn fft10<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 10] {
    let n = 10;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft2([x[0], x[5]]);
    let row1 = fft2([x[2], x[7]]);
    let row2 = fft2([x[4], x[9]]);
    let row3 = fft2([x[6], x[1]]);
    let row4 = fft2([x[8], x[3]]);

    let col0 = fft5([row0[0], row1[0], row2[0], row3[0], row4[0]]);
    let col1 = fft5([row0[1], row1[1], row2[1], row3[1], row4[1]]);

    [
        col0[0], col1[1], col0[2], col1[3], col0[4], col1[0], col0[1], col1[2], col0[3], col1[4],
    ]
}

#[inline]
pub fn fft11<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 11] {
    let n = 11;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.84125353283118121).unwrap(),
        T::from(-0.54064081745559756).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.41541501300188644).unwrap(),
        T::from(-0.90963199535451833).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(-0.142314838273285).unwrap(),
        T::from(-0.9898214418809328).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.65486073394528499).unwrap(),
        T::from(-0.75574957435425838).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.95949297361449736).unwrap(),
        T::from(-0.28173255684142962).unwrap(),
    );

    let x110p = x[1] + x[10];
    let x110n = x[1] - x[10];
    let x29p = x[2] + x[9];
    let x29n = x[2] - x[9];
    let x38p = x[3] + x[8];
    let x38n = x[3] - x[8];
    let x47p = x[4] + x[7];
    let x47n = x[4] - x[7];
    let x56p = x[5] + x[6];
    let x56n = x[5] - x[6];
    let sum = x[0] + x110p + x29p + x38p + x47p + x56p;
    let b110re_a = x[0].re
        + twiddle1.re * x110p.re
        + twiddle2.re * x29p.re
        + twiddle3.re * x38p.re
        + twiddle4.re * x47p.re
        + twiddle5.re * x56p.re;
    let b110re_b = twiddle1.im * x110n.im
        + twiddle2.im * x29n.im
        + twiddle3.im * x38n.im
        + twiddle4.im * x47n.im
        + twiddle5.im * x56n.im;
    let b29re_a = x[0].re
        + twiddle2.re * x110p.re
        + twiddle4.re * x29p.re
        + twiddle5.re * x38p.re
        + twiddle3.re * x47p.re
        + twiddle1.re * x56p.re;
    let b29re_b = twiddle2.im * x110n.im
        + twiddle4.im * x29n.im
        + -twiddle5.im * x38n.im
        + -twiddle3.im * x47n.im
        + -twiddle1.im * x56n.im;
    let b38re_a = x[0].re
        + twiddle3.re * x110p.re
        + twiddle5.re * x29p.re
        + twiddle2.re * x38p.re
        + twiddle1.re * x47p.re
        + twiddle4.re * x56p.re;
    let b38re_b = twiddle3.im * x110n.im
        + -twiddle5.im * x29n.im
        + -twiddle2.im * x38n.im
        + twiddle1.im * x47n.im
        + twiddle4.im * x56n.im;
    let b47re_a = x[0].re
        + twiddle4.re * x110p.re
        + twiddle3.re * x29p.re
        + twiddle1.re * x38p.re
        + twiddle5.re * x47p.re
        + twiddle2.re * x56p.re;
    let b47re_b = twiddle4.im * x110n.im
        + -twiddle3.im * x29n.im
        + twiddle1.im * x38n.im
        + twiddle5.im * x47n.im
        + -twiddle2.im * x56n.im;
    let b56re_a = x[0].re
        + twiddle5.re * x110p.re
        + twiddle1.re * x29p.re
        + twiddle4.re * x38p.re
        + twiddle2.re * x47p.re
        + twiddle3.re * x56p.re;
    let b56re_b = twiddle5.im * x110n.im
        + -twiddle1.im * x29n.im
        + twiddle4.im * x38n.im
        + -twiddle2.im * x47n.im
        + twiddle3.im * x56n.im;

    let b110im_a = x[0].im
        + twiddle1.re * x110p.im
        + twiddle2.re * x29p.im
        + twiddle3.re * x38p.im
        + twiddle4.re * x47p.im
        + twiddle5.re * x56p.im;
    let b110im_b = twiddle1.im * x110n.re
        + twiddle2.im * x29n.re
        + twiddle3.im * x38n.re
        + twiddle4.im * x47n.re
        + twiddle5.im * x56n.re;
    let b29im_a = x[0].im
        + twiddle2.re * x110p.im
        + twiddle4.re * x29p.im
        + twiddle5.re * x38p.im
        + twiddle3.re * x47p.im
        + twiddle1.re * x56p.im;
    let b29im_b = twiddle2.im * x110n.re
        + twiddle4.im * x29n.re
        + -twiddle5.im * x38n.re
        + -twiddle3.im * x47n.re
        + -twiddle1.im * x56n.re;
    let b38im_a = x[0].im
        + twiddle3.re * x110p.im
        + twiddle5.re * x29p.im
        + twiddle2.re * x38p.im
        + twiddle1.re * x47p.im
        + twiddle4.re * x56p.im;
    let b38im_b = twiddle3.im * x110n.re
        + -twiddle5.im * x29n.re
        + -twiddle2.im * x38n.re
        + twiddle1.im * x47n.re
        + twiddle4.im * x56n.re;
    let b47im_a = x[0].im
        + twiddle4.re * x110p.im
        + twiddle3.re * x29p.im
        + twiddle1.re * x38p.im
        + twiddle5.re * x47p.im
        + twiddle2.re * x56p.im;
    let b47im_b = twiddle4.im * x110n.re
        + -twiddle3.im * x29n.re
        + twiddle1.im * x38n.re
        + twiddle5.im * x47n.re
        + -twiddle2.im * x56n.re;
    let b56im_a = x[0].im
        + twiddle5.re * x110p.im
        + twiddle1.re * x29p.im
        + twiddle4.re * x38p.im
        + twiddle2.re * x47p.im
        + twiddle3.re * x56p.im;
    let b56im_b = twiddle5.im * x110n.re
        + -twiddle1.im * x29n.re
        + twiddle4.im * x38n.re
        + -twiddle2.im * x47n.re
        + twiddle3.im * x56n.re;

    let out1re = b110re_a - b110re_b;
    let out1im = b110im_a + b110im_b;
    let out2re = b29re_a - b29re_b;
    let out2im = b29im_a + b29im_b;
    let out3re = b38re_a - b38re_b;
    let out3im = b38im_a + b38im_b;
    let out4re = b47re_a - b47re_b;
    let out4im = b47im_a + b47im_b;
    let out5re = b56re_a - b56re_b;
    let out5im = b56im_a + b56im_b;
    let out6re = b56re_a + b56re_b;
    let out6im = b56im_a - b56im_b;
    let out7re = b47re_a + b47re_b;
    let out7im = b47im_a - b47im_b;
    let out8re = b38re_a + b38re_b;
    let out8im = b38im_a - b38im_b;
    let out9re = b29re_a + b29re_b;
    let out9im = b29im_a - b29im_b;
    let out10re = b110re_a + b110re_b;
    let out10im = b110im_a - b110im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
    ]
}

#[inline]
pub fn fft12<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 12] {
    let n = 12;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let column0 = fft4([x[0], x[3], x[6], x[9]]);
    let column1 = fft4([x[4], x[7], x[10], x[1]]);
    let column2 = fft4([x[8], x[11], x[2], x[5]]);

    let row0 = fft3([column0[0], column1[0], column2[0]]);
    let row1 = fft3([column0[1], column1[1], column2[1]]);
    let row2 = fft3([column0[2], column1[2], column2[2]]);
    let row3 = fft3([column0[3], column1[3], column2[3]]);

    [
        row0[0], row1[1], row2[2], row3[0], row0[1], row1[2], row2[0], row3[1], row0[2], row1[0],
        row2[1], row3[2],
    ]
}

#[inline]
pub fn fft13<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 13] {
    let n = 13;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.88545602565320991).unwrap(),
        T::from(-0.46472317204376851).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.56806474673115592).unwrap(),
        T::from(-0.82298386589365635).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(0.12053668025532323).unwrap(),
        T::from(-0.99270887409805397).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(-0.35460488704253545).unwrap(),
        T::from(-0.93501624268541483).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.74851074817110086).unwrap(),
        T::from(-0.66312265824079553).unwrap(),
    );
    let twiddle6: Complex<T> = Complex::new(
        T::from(-0.9709418174260519).unwrap(),
        T::from(-0.2393156642875581).unwrap(),
    );

    let x112p = x[1] + x[12];
    let x112n = x[1] - x[12];
    let x211p = x[2] + x[11];
    let x211n = x[2] - x[11];
    let x310p = x[3] + x[10];
    let x310n = x[3] - x[10];
    let x49p = x[4] + x[9];
    let x49n = x[4] - x[9];
    let x58p = x[5] + x[8];
    let x58n = x[5] - x[8];
    let x67p = x[6] + x[7];
    let x67n = x[6] - x[7];
    let sum = x[0] + x112p + x211p + x310p + x49p + x58p + x67p;
    let b112re_a = x[0].re
        + twiddle1.re * x112p.re
        + twiddle2.re * x211p.re
        + twiddle3.re * x310p.re
        + twiddle4.re * x49p.re
        + twiddle5.re * x58p.re
        + twiddle6.re * x67p.re;
    let b112re_b = twiddle1.im * x112n.im
        + twiddle2.im * x211n.im
        + twiddle3.im * x310n.im
        + twiddle4.im * x49n.im
        + twiddle5.im * x58n.im
        + twiddle6.im * x67n.im;
    let b211re_a = x[0].re
        + twiddle2.re * x112p.re
        + twiddle4.re * x211p.re
        + twiddle6.re * x310p.re
        + twiddle5.re * x49p.re
        + twiddle3.re * x58p.re
        + twiddle1.re * x67p.re;
    let b211re_b = twiddle2.im * x112n.im
        + twiddle4.im * x211n.im
        + twiddle6.im * x310n.im
        + -twiddle5.im * x49n.im
        + -twiddle3.im * x58n.im
        + -twiddle1.im * x67n.im;
    let b310re_a = x[0].re
        + twiddle3.re * x112p.re
        + twiddle6.re * x211p.re
        + twiddle4.re * x310p.re
        + twiddle1.re * x49p.re
        + twiddle2.re * x58p.re
        + twiddle5.re * x67p.re;
    let b310re_b = twiddle3.im * x112n.im
        + twiddle6.im * x211n.im
        + -twiddle4.im * x310n.im
        + -twiddle1.im * x49n.im
        + twiddle2.im * x58n.im
        + twiddle5.im * x67n.im;
    let b49re_a = x[0].re
        + twiddle4.re * x112p.re
        + twiddle5.re * x211p.re
        + twiddle1.re * x310p.re
        + twiddle3.re * x49p.re
        + twiddle6.re * x58p.re
        + twiddle2.re * x67p.re;
    let b49re_b = twiddle4.im * x112n.im
        + -twiddle5.im * x211n.im
        + -twiddle1.im * x310n.im
        + twiddle3.im * x49n.im
        + -twiddle6.im * x58n.im
        + -twiddle2.im * x67n.im;
    let b58re_a = x[0].re
        + twiddle5.re * x112p.re
        + twiddle3.re * x211p.re
        + twiddle2.re * x310p.re
        + twiddle6.re * x49p.re
        + twiddle1.re * x58p.re
        + twiddle4.re * x67p.re;
    let b58re_b = twiddle5.im * x112n.im
        + -twiddle3.im * x211n.im
        + twiddle2.im * x310n.im
        + -twiddle6.im * x49n.im
        + -twiddle1.im * x58n.im
        + twiddle4.im * x67n.im;
    let b67re_a = x[0].re
        + twiddle6.re * x112p.re
        + twiddle1.re * x211p.re
        + twiddle5.re * x310p.re
        + twiddle2.re * x49p.re
        + twiddle4.re * x58p.re
        + twiddle3.re * x67p.re;
    let b67re_b = twiddle6.im * x112n.im
        + -twiddle1.im * x211n.im
        + twiddle5.im * x310n.im
        + -twiddle2.im * x49n.im
        + twiddle4.im * x58n.im
        + -twiddle3.im * x67n.im;

    let b112im_a = x[0].im
        + twiddle1.re * x112p.im
        + twiddle2.re * x211p.im
        + twiddle3.re * x310p.im
        + twiddle4.re * x49p.im
        + twiddle5.re * x58p.im
        + twiddle6.re * x67p.im;
    let b112im_b = twiddle1.im * x112n.re
        + twiddle2.im * x211n.re
        + twiddle3.im * x310n.re
        + twiddle4.im * x49n.re
        + twiddle5.im * x58n.re
        + twiddle6.im * x67n.re;
    let b211im_a = x[0].im
        + twiddle2.re * x112p.im
        + twiddle4.re * x211p.im
        + twiddle6.re * x310p.im
        + twiddle5.re * x49p.im
        + twiddle3.re * x58p.im
        + twiddle1.re * x67p.im;
    let b211im_b = twiddle2.im * x112n.re
        + twiddle4.im * x211n.re
        + twiddle6.im * x310n.re
        + -twiddle5.im * x49n.re
        + -twiddle3.im * x58n.re
        + -twiddle1.im * x67n.re;
    let b310im_a = x[0].im
        + twiddle3.re * x112p.im
        + twiddle6.re * x211p.im
        + twiddle4.re * x310p.im
        + twiddle1.re * x49p.im
        + twiddle2.re * x58p.im
        + twiddle5.re * x67p.im;
    let b310im_b = twiddle3.im * x112n.re
        + twiddle6.im * x211n.re
        + -twiddle4.im * x310n.re
        + -twiddle1.im * x49n.re
        + twiddle2.im * x58n.re
        + twiddle5.im * x67n.re;
    let b49im_a = x[0].im
        + twiddle4.re * x112p.im
        + twiddle5.re * x211p.im
        + twiddle1.re * x310p.im
        + twiddle3.re * x49p.im
        + twiddle6.re * x58p.im
        + twiddle2.re * x67p.im;
    let b49im_b = twiddle4.im * x112n.re
        + -twiddle5.im * x211n.re
        + -twiddle1.im * x310n.re
        + twiddle3.im * x49n.re
        + -twiddle6.im * x58n.re
        + -twiddle2.im * x67n.re;
    let b58im_a = x[0].im
        + twiddle5.re * x112p.im
        + twiddle3.re * x211p.im
        + twiddle2.re * x310p.im
        + twiddle6.re * x49p.im
        + twiddle1.re * x58p.im
        + twiddle4.re * x67p.im;
    let b58im_b = twiddle5.im * x112n.re
        + -twiddle3.im * x211n.re
        + twiddle2.im * x310n.re
        + -twiddle6.im * x49n.re
        + -twiddle1.im * x58n.re
        + twiddle4.im * x67n.re;
    let b67im_a = x[0].im
        + twiddle6.re * x112p.im
        + twiddle1.re * x211p.im
        + twiddle5.re * x310p.im
        + twiddle2.re * x49p.im
        + twiddle4.re * x58p.im
        + twiddle3.re * x67p.im;
    let b67im_b = twiddle6.im * x112n.re
        + -twiddle1.im * x211n.re
        + twiddle5.im * x310n.re
        + -twiddle2.im * x49n.re
        + twiddle4.im * x58n.re
        + -twiddle3.im * x67n.re;

    let out1re = b112re_a - b112re_b;
    let out1im = b112im_a + b112im_b;
    let out2re = b211re_a - b211re_b;
    let out2im = b211im_a + b211im_b;
    let out3re = b310re_a - b310re_b;
    let out3im = b310im_a + b310im_b;
    let out4re = b49re_a - b49re_b;
    let out4im = b49im_a + b49im_b;
    let out5re = b58re_a - b58re_b;
    let out5im = b58im_a + b58im_b;
    let out6re = b67re_a - b67re_b;
    let out6im = b67im_a + b67im_b;
    let out7re = b67re_a + b67re_b;
    let out7im = b67im_a - b67im_b;
    let out8re = b58re_a + b58re_b;
    let out8im = b58im_a - b58im_b;
    let out9re = b49re_a + b49re_b;
    let out9im = b49im_a - b49im_b;
    let out10re = b310re_a + b310re_b;
    let out10im = b310im_a - b310im_b;
    let out11re = b211re_a + b211re_b;
    let out11im = b211im_a - b211im_b;
    let out12re = b112re_a + b112re_b;
    let out12im = b112im_a - b112im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
        Complex::new(out11re, out11im),
        Complex::new(out12re, out12im),
    ]
}

#[inline]
pub fn fft14<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 14] {
    let n = 14;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft2([x[0], x[7]]);
    let row1 = fft2([x[2], x[9]]);
    let row2 = fft2([x[4], x[11]]);
    let row3 = fft2([x[6], x[13]]);
    let row4 = fft2([x[8], x[1]]);
    let row5 = fft2([x[10], x[3]]);
    let row6 = fft2([x[12], x[5]]);

    let col0 = fft7([
        row0[0], row1[0], row2[0], row3[0], row4[0], row5[0], row6[0],
    ]);
    let col1 = fft7([
        row0[1], row1[1], row2[1], row3[1], row4[1], row5[1], row6[1],
    ]);

    [
        col0[0], col1[1], col0[2], col1[3], col0[4], col1[5], col0[6], col1[0], col0[1], col1[2],
        col0[3], col1[4], col0[5], col1[6],
    ]
}

#[inline]
pub fn fft15<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 15] {
    let n = 15;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft3([x[0], x[5], x[10]]);
    let row1 = fft3([x[3], x[8], x[13]]);
    let row2 = fft3([x[6], x[11], x[1]]);
    let row3 = fft3([x[9], x[14], x[4]]);
    let row4 = fft3([x[12], x[2], x[7]]);

    let col0 = fft5([row0[0], row1[0], row2[0], row3[0], row4[0]]);
    let col1 = fft5([row0[1], row1[1], row2[1], row3[1], row4[1]]);
    let col2 = fft5([row0[2], row1[2], row2[2], row3[2], row4[2]]);

    [
        col0[0], col1[1], col2[2], col0[3], col1[4], col2[0], col0[1], col1[2], col2[3], col0[4],
        col1[0], col2[1], col0[2], col1[3], col2[4],
    ]
}

#[inline]
pub fn fft17<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 17] {
    let n = 17;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.93247222940435581).unwrap(),
        T::from(-0.36124166618715292).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.73900891722065909).unwrap(),
        T::from(-0.67369564364655721).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(0.44573835577653831).unwrap(),
        T::from(-0.89516329135506234).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(0.092268359463302002).unwrap(),
        T::from(-0.99573417629503447).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.27366299007208289).unwrap(),
        T::from(-0.96182564317281904).unwrap(),
    );
    let twiddle6: Complex<T> = Complex::new(
        T::from(-0.60263463637925618).unwrap(),
        T::from(-0.7980172272802396).unwrap(),
    );
    let twiddle7: Complex<T> = Complex::new(
        T::from(-0.85021713572961422).unwrap(),
        T::from(-0.52643216287735572).unwrap(),
    );
    let twiddle8: Complex<T> = Complex::new(
        T::from(-0.98297309968390178).unwrap(),
        T::from(-0.18374951781657037).unwrap(),
    );

    let x116p = x[1] + x[16];
    let x116n = x[1] - x[16];
    let x215p = x[2] + x[15];
    let x215n = x[2] - x[15];
    let x314p = x[3] + x[14];
    let x314n = x[3] - x[14];
    let x413p = x[4] + x[13];
    let x413n = x[4] - x[13];
    let x512p = x[5] + x[12];
    let x512n = x[5] - x[12];
    let x611p = x[6] + x[11];
    let x611n = x[6] - x[11];
    let x710p = x[7] + x[10];
    let x710n = x[7] - x[10];
    let x89p = x[8] + x[9];
    let x89n = x[8] - x[9];
    let sum = x[0] + x116p + x215p + x314p + x413p + x512p + x611p + x710p + x89p;
    let b116re_a = x[0].re
        + twiddle1.re * x116p.re
        + twiddle2.re * x215p.re
        + twiddle3.re * x314p.re
        + twiddle4.re * x413p.re
        + twiddle5.re * x512p.re
        + twiddle6.re * x611p.re
        + twiddle7.re * x710p.re
        + twiddle8.re * x89p.re;
    let b116re_b = twiddle1.im * x116n.im
        + twiddle2.im * x215n.im
        + twiddle3.im * x314n.im
        + twiddle4.im * x413n.im
        + twiddle5.im * x512n.im
        + twiddle6.im * x611n.im
        + twiddle7.im * x710n.im
        + twiddle8.im * x89n.im;
    let b215re_a = x[0].re
        + twiddle2.re * x116p.re
        + twiddle4.re * x215p.re
        + twiddle6.re * x314p.re
        + twiddle8.re * x413p.re
        + twiddle7.re * x512p.re
        + twiddle5.re * x611p.re
        + twiddle3.re * x710p.re
        + twiddle1.re * x89p.re;
    let b215re_b = twiddle2.im * x116n.im
        + twiddle4.im * x215n.im
        + twiddle6.im * x314n.im
        + twiddle8.im * x413n.im
        + -twiddle7.im * x512n.im
        + -twiddle5.im * x611n.im
        + -twiddle3.im * x710n.im
        + -twiddle1.im * x89n.im;
    let b314re_a = x[0].re
        + twiddle3.re * x116p.re
        + twiddle6.re * x215p.re
        + twiddle8.re * x314p.re
        + twiddle5.re * x413p.re
        + twiddle2.re * x512p.re
        + twiddle1.re * x611p.re
        + twiddle4.re * x710p.re
        + twiddle7.re * x89p.re;
    let b314re_b = twiddle3.im * x116n.im
        + twiddle6.im * x215n.im
        + -twiddle8.im * x314n.im
        + -twiddle5.im * x413n.im
        + -twiddle2.im * x512n.im
        + twiddle1.im * x611n.im
        + twiddle4.im * x710n.im
        + twiddle7.im * x89n.im;
    let b413re_a = x[0].re
        + twiddle4.re * x116p.re
        + twiddle8.re * x215p.re
        + twiddle5.re * x314p.re
        + twiddle1.re * x413p.re
        + twiddle3.re * x512p.re
        + twiddle7.re * x611p.re
        + twiddle6.re * x710p.re
        + twiddle2.re * x89p.re;
    let b413re_b = twiddle4.im * x116n.im
        + twiddle8.im * x215n.im
        + -twiddle5.im * x314n.im
        + -twiddle1.im * x413n.im
        + twiddle3.im * x512n.im
        + twiddle7.im * x611n.im
        + -twiddle6.im * x710n.im
        + -twiddle2.im * x89n.im;
    let b512re_a = x[0].re
        + twiddle5.re * x116p.re
        + twiddle7.re * x215p.re
        + twiddle2.re * x314p.re
        + twiddle3.re * x413p.re
        + twiddle8.re * x512p.re
        + twiddle4.re * x611p.re
        + twiddle1.re * x710p.re
        + twiddle6.re * x89p.re;
    let b512re_b = twiddle5.im * x116n.im
        + -twiddle7.im * x215n.im
        + -twiddle2.im * x314n.im
        + twiddle3.im * x413n.im
        + twiddle8.im * x512n.im
        + -twiddle4.im * x611n.im
        + twiddle1.im * x710n.im
        + twiddle6.im * x89n.im;
    let b611re_a = x[0].re
        + twiddle6.re * x116p.re
        + twiddle5.re * x215p.re
        + twiddle1.re * x314p.re
        + twiddle7.re * x413p.re
        + twiddle4.re * x512p.re
        + twiddle2.re * x611p.re
        + twiddle8.re * x710p.re
        + twiddle3.re * x89p.re;
    let b611re_b = twiddle6.im * x116n.im
        + -twiddle5.im * x215n.im
        + twiddle1.im * x314n.im
        + twiddle7.im * x413n.im
        + -twiddle4.im * x512n.im
        + twiddle2.im * x611n.im
        + twiddle8.im * x710n.im
        + -twiddle3.im * x89n.im;
    let b710re_a = x[0].re
        + twiddle7.re * x116p.re
        + twiddle3.re * x215p.re
        + twiddle4.re * x314p.re
        + twiddle6.re * x413p.re
        + twiddle1.re * x512p.re
        + twiddle8.re * x611p.re
        + twiddle2.re * x710p.re
        + twiddle5.re * x89p.re;
    let b710re_b = twiddle7.im * x116n.im
        + -twiddle3.im * x215n.im
        + twiddle4.im * x314n.im
        + -twiddle6.im * x413n.im
        + twiddle1.im * x512n.im
        + twiddle8.im * x611n.im
        + -twiddle2.im * x710n.im
        + twiddle5.im * x89n.im;
    let b89re_a = x[0].re
        + twiddle8.re * x116p.re
        + twiddle1.re * x215p.re
        + twiddle7.re * x314p.re
        + twiddle2.re * x413p.re
        + twiddle6.re * x512p.re
        + twiddle3.re * x611p.re
        + twiddle5.re * x710p.re
        + twiddle4.re * x89p.re;
    let b89re_b = twiddle8.im * x116n.im
        + -twiddle1.im * x215n.im
        + twiddle7.im * x314n.im
        + -twiddle2.im * x413n.im
        + twiddle6.im * x512n.im
        + -twiddle3.im * x611n.im
        + twiddle5.im * x710n.im
        + -twiddle4.im * x89n.im;

    let b116im_a = x[0].im
        + twiddle1.re * x116p.im
        + twiddle2.re * x215p.im
        + twiddle3.re * x314p.im
        + twiddle4.re * x413p.im
        + twiddle5.re * x512p.im
        + twiddle6.re * x611p.im
        + twiddle7.re * x710p.im
        + twiddle8.re * x89p.im;
    let b116im_b = twiddle1.im * x116n.re
        + twiddle2.im * x215n.re
        + twiddle3.im * x314n.re
        + twiddle4.im * x413n.re
        + twiddle5.im * x512n.re
        + twiddle6.im * x611n.re
        + twiddle7.im * x710n.re
        + twiddle8.im * x89n.re;
    let b215im_a = x[0].im
        + twiddle2.re * x116p.im
        + twiddle4.re * x215p.im
        + twiddle6.re * x314p.im
        + twiddle8.re * x413p.im
        + twiddle7.re * x512p.im
        + twiddle5.re * x611p.im
        + twiddle3.re * x710p.im
        + twiddle1.re * x89p.im;
    let b215im_b = twiddle2.im * x116n.re
        + twiddle4.im * x215n.re
        + twiddle6.im * x314n.re
        + twiddle8.im * x413n.re
        + -twiddle7.im * x512n.re
        + -twiddle5.im * x611n.re
        + -twiddle3.im * x710n.re
        + -twiddle1.im * x89n.re;
    let b314im_a = x[0].im
        + twiddle3.re * x116p.im
        + twiddle6.re * x215p.im
        + twiddle8.re * x314p.im
        + twiddle5.re * x413p.im
        + twiddle2.re * x512p.im
        + twiddle1.re * x611p.im
        + twiddle4.re * x710p.im
        + twiddle7.re * x89p.im;
    let b314im_b = twiddle3.im * x116n.re
        + twiddle6.im * x215n.re
        + -twiddle8.im * x314n.re
        + -twiddle5.im * x413n.re
        + -twiddle2.im * x512n.re
        + twiddle1.im * x611n.re
        + twiddle4.im * x710n.re
        + twiddle7.im * x89n.re;
    let b413im_a = x[0].im
        + twiddle4.re * x116p.im
        + twiddle8.re * x215p.im
        + twiddle5.re * x314p.im
        + twiddle1.re * x413p.im
        + twiddle3.re * x512p.im
        + twiddle7.re * x611p.im
        + twiddle6.re * x710p.im
        + twiddle2.re * x89p.im;
    let b413im_b = twiddle4.im * x116n.re
        + twiddle8.im * x215n.re
        + -twiddle5.im * x314n.re
        + -twiddle1.im * x413n.re
        + twiddle3.im * x512n.re
        + twiddle7.im * x611n.re
        + -twiddle6.im * x710n.re
        + -twiddle2.im * x89n.re;
    let b512im_a = x[0].im
        + twiddle5.re * x116p.im
        + twiddle7.re * x215p.im
        + twiddle2.re * x314p.im
        + twiddle3.re * x413p.im
        + twiddle8.re * x512p.im
        + twiddle4.re * x611p.im
        + twiddle1.re * x710p.im
        + twiddle6.re * x89p.im;
    let b512im_b = twiddle5.im * x116n.re
        + -twiddle7.im * x215n.re
        + -twiddle2.im * x314n.re
        + twiddle3.im * x413n.re
        + twiddle8.im * x512n.re
        + -twiddle4.im * x611n.re
        + twiddle1.im * x710n.re
        + twiddle6.im * x89n.re;
    let b611im_a = x[0].im
        + twiddle6.re * x116p.im
        + twiddle5.re * x215p.im
        + twiddle1.re * x314p.im
        + twiddle7.re * x413p.im
        + twiddle4.re * x512p.im
        + twiddle2.re * x611p.im
        + twiddle8.re * x710p.im
        + twiddle3.re * x89p.im;
    let b611im_b = twiddle6.im * x116n.re
        + -twiddle5.im * x215n.re
        + twiddle1.im * x314n.re
        + twiddle7.im * x413n.re
        + -twiddle4.im * x512n.re
        + twiddle2.im * x611n.re
        + twiddle8.im * x710n.re
        + -twiddle3.im * x89n.re;
    let b710im_a = x[0].im
        + twiddle7.re * x116p.im
        + twiddle3.re * x215p.im
        + twiddle4.re * x314p.im
        + twiddle6.re * x413p.im
        + twiddle1.re * x512p.im
        + twiddle8.re * x611p.im
        + twiddle2.re * x710p.im
        + twiddle5.re * x89p.im;
    let b710im_b = twiddle7.im * x116n.re
        + -twiddle3.im * x215n.re
        + twiddle4.im * x314n.re
        + -twiddle6.im * x413n.re
        + twiddle1.im * x512n.re
        + twiddle8.im * x611n.re
        + -twiddle2.im * x710n.re
        + twiddle5.im * x89n.re;
    let b89im_a = x[0].im
        + twiddle8.re * x116p.im
        + twiddle1.re * x215p.im
        + twiddle7.re * x314p.im
        + twiddle2.re * x413p.im
        + twiddle6.re * x512p.im
        + twiddle3.re * x611p.im
        + twiddle5.re * x710p.im
        + twiddle4.re * x89p.im;
    let b89im_b = twiddle8.im * x116n.re
        + -twiddle1.im * x215n.re
        + twiddle7.im * x314n.re
        + -twiddle2.im * x413n.re
        + twiddle6.im * x512n.re
        + -twiddle3.im * x611n.re
        + twiddle5.im * x710n.re
        + -twiddle4.im * x89n.re;

    let out1re = b116re_a - b116re_b;
    let out1im = b116im_a + b116im_b;
    let out2re = b215re_a - b215re_b;
    let out2im = b215im_a + b215im_b;
    let out3re = b314re_a - b314re_b;
    let out3im = b314im_a + b314im_b;
    let out4re = b413re_a - b413re_b;
    let out4im = b413im_a + b413im_b;
    let out5re = b512re_a - b512re_b;
    let out5im = b512im_a + b512im_b;
    let out6re = b611re_a - b611re_b;
    let out6im = b611im_a + b611im_b;
    let out7re = b710re_a - b710re_b;
    let out7im = b710im_a + b710im_b;
    let out8re = b89re_a - b89re_b;
    let out8im = b89im_a + b89im_b;
    let out9re = b89re_a + b89re_b;
    let out9im = b89im_a - b89im_b;
    let out10re = b710re_a + b710re_b;
    let out10im = b710im_a - b710im_b;
    let out11re = b611re_a + b611re_b;
    let out11im = b611im_a - b611im_b;
    let out12re = b512re_a + b512re_b;
    let out12im = b512im_a - b512im_b;
    let out13re = b413re_a + b413re_b;
    let out13im = b413im_a - b413im_b;
    let out14re = b314re_a + b314re_b;
    let out14im = b314im_a - b314im_b;
    let out15re = b215re_a + b215re_b;
    let out15im = b215im_a - b215im_b;
    let out16re = b116re_a + b116re_b;
    let out16im = b116im_a - b116im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
        Complex::new(out11re, out11im),
        Complex::new(out12re, out12im),
        Complex::new(out13re, out13im),
        Complex::new(out14re, out14im),
        Complex::new(out15re, out15im),
        Complex::new(out16re, out16im),
    ]
}

#[inline]
pub fn fft18<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 18] {
    let n = 18;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle0 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle1 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle2 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle3 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle4 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle5 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle6 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle7 = Complex::new(
        T::from(0.93969262078590842).unwrap(),
        T::from(-0.34202014332566871).unwrap(),
    );
    let twiddle8 = Complex::new(
        T::from(0.76604444311897801).unwrap(),
        T::from(-0.64278760968653925).unwrap(),
    );
    let twiddle9 = Complex::new(T::from(0.5).unwrap(), T::from(-0.8660254037844386).unwrap());
    let twiddle10 = Complex::new(
        T::from(0.17364817766693041).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle11 = Complex::new(
        T::from(-0.1736481776669303).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle12 = Complex::new(T::from(1.0).unwrap(), T::from(0.0).unwrap());
    let twiddle13 = Complex::new(
        T::from(0.76604444311897801).unwrap(),
        T::from(-0.64278760968653925).unwrap(),
    );
    let twiddle14 = Complex::new(
        T::from(0.17364817766693041).unwrap(),
        T::from(-0.98480775301220802).unwrap(),
    );
    let twiddle15 = Complex::new(
        T::from(-0.5).unwrap(),
        T::from(-0.86602540378443881).unwrap(),
    );
    let twiddle16 = Complex::new(
        T::from(-0.93969262078590832).unwrap(),
        T::from(-0.34202014332566888).unwrap(),
    );
    let twiddle17 = Complex::new(
        T::from(-0.93969262078590842).unwrap(),
        T::from(0.34202014332566866).unwrap(),
    );

    let row0 = fft6([x[0], x[3], x[6], x[9], x[12], x[15]]);
    let row1 = fft6([x[1], x[4], x[7], x[10], x[13], x[16]]);
    let row2 = fft6([x[2], x[5], x[8], x[11], x[14], x[17]]);

    let col0 = fft3([row0[0] * twiddle0, row1[0] * twiddle6, row2[0] * twiddle12]);
    let col1 = fft3([row0[1] * twiddle1, row1[1] * twiddle7, row2[1] * twiddle13]);
    let col2 = fft3([row0[2] * twiddle2, row1[2] * twiddle8, row2[2] * twiddle14]);
    let col3 = fft3([row0[3] * twiddle3, row1[3] * twiddle9, row2[3] * twiddle15]);
    let col4 = fft3([row0[4] * twiddle4, row1[4] * twiddle10, row2[4] * twiddle16]);
    let col5 = fft3([row0[5] * twiddle5, row1[5] * twiddle11, row2[5] * twiddle17]);

    [
        col0[0], col1[0], col2[0], col3[0], col4[0], col5[0], col0[1], col1[1], col2[1], col3[1],
        col4[1], col5[1], col0[2], col1[2], col2[2], col3[2], col4[2], col5[2],
    ]
}

#[inline]
pub fn fft19<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 19] {
    let n = 19;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let twiddle1: Complex<T> = Complex::new(
        T::from(0.94581724170063464).unwrap(),
        T::from(-0.32469946920468346).unwrap(),
    );
    let twiddle2: Complex<T> = Complex::new(
        T::from(0.78914050939639357).unwrap(),
        T::from(-0.61421271268966782).unwrap(),
    );
    let twiddle3: Complex<T> = Complex::new(
        T::from(0.54694815812242703).unwrap(),
        T::from(-0.83716647826252844).unwrap(),
    );
    let twiddle4: Complex<T> = Complex::new(
        T::from(0.24548548714079924).unwrap(),
        T::from(-0.96940026593933037).unwrap(),
    );
    let twiddle5: Complex<T> = Complex::new(
        T::from(-0.082579345472332282).unwrap(),
        T::from(-0.99658449300666985).unwrap(),
    );
    let twiddle6: Complex<T> = Complex::new(
        T::from(-0.40169542465296926).unwrap(),
        T::from(-0.91577332665505751).unwrap(),
    );
    let twiddle7: Complex<T> = Complex::new(
        T::from(-0.67728157162574087).unwrap(),
        T::from(-0.73572391067313181).unwrap(),
    );
    let twiddle8: Complex<T> = Complex::new(
        T::from(-0.87947375120648896).unwrap(),
        T::from(-0.47594739303707367).unwrap(),
    );
    let twiddle9: Complex<T> = Complex::new(
        T::from(-0.98636130340272232).unwrap(),
        T::from(-0.16459459028073403).unwrap(),
    );

    let x118p = x[1] + x[18];
    let x118n = x[1] - x[18];
    let x217p = x[2] + x[17];
    let x217n = x[2] - x[17];
    let x316p = x[3] + x[16];
    let x316n = x[3] - x[16];
    let x415p = x[4] + x[15];
    let x415n = x[4] - x[15];
    let x514p = x[5] + x[14];
    let x514n = x[5] - x[14];
    let x613p = x[6] + x[13];
    let x613n = x[6] - x[13];
    let x712p = x[7] + x[12];
    let x712n = x[7] - x[12];
    let x811p = x[8] + x[11];
    let x811n = x[8] - x[11];
    let x910p = x[9] + x[10];
    let x910n = x[9] - x[10];
    let sum = x[0] + x118p + x217p + x316p + x415p + x514p + x613p + x712p + x811p + x910p;
    let b118re_a = x[0].re
        + twiddle1.re * x118p.re
        + twiddle2.re * x217p.re
        + twiddle3.re * x316p.re
        + twiddle4.re * x415p.re
        + twiddle5.re * x514p.re
        + twiddle6.re * x613p.re
        + twiddle7.re * x712p.re
        + twiddle8.re * x811p.re
        + twiddle9.re * x910p.re;
    let b118re_b = twiddle1.im * x118n.im
        + twiddle2.im * x217n.im
        + twiddle3.im * x316n.im
        + twiddle4.im * x415n.im
        + twiddle5.im * x514n.im
        + twiddle6.im * x613n.im
        + twiddle7.im * x712n.im
        + twiddle8.im * x811n.im
        + twiddle9.im * x910n.im;
    let b217re_a = x[0].re
        + twiddle2.re * x118p.re
        + twiddle4.re * x217p.re
        + twiddle6.re * x316p.re
        + twiddle8.re * x415p.re
        + twiddle9.re * x514p.re
        + twiddle7.re * x613p.re
        + twiddle5.re * x712p.re
        + twiddle3.re * x811p.re
        + twiddle1.re * x910p.re;
    let b217re_b = twiddle2.im * x118n.im
        + twiddle4.im * x217n.im
        + twiddle6.im * x316n.im
        + twiddle8.im * x415n.im
        + -twiddle9.im * x514n.im
        + -twiddle7.im * x613n.im
        + -twiddle5.im * x712n.im
        + -twiddle3.im * x811n.im
        + -twiddle1.im * x910n.im;
    let b316re_a = x[0].re
        + twiddle3.re * x118p.re
        + twiddle6.re * x217p.re
        + twiddle9.re * x316p.re
        + twiddle7.re * x415p.re
        + twiddle4.re * x514p.re
        + twiddle1.re * x613p.re
        + twiddle2.re * x712p.re
        + twiddle5.re * x811p.re
        + twiddle8.re * x910p.re;
    let b316re_b = twiddle3.im * x118n.im
        + twiddle6.im * x217n.im
        + twiddle9.im * x316n.im
        + -twiddle7.im * x415n.im
        + -twiddle4.im * x514n.im
        + -twiddle1.im * x613n.im
        + twiddle2.im * x712n.im
        + twiddle5.im * x811n.im
        + twiddle8.im * x910n.im;
    let b415re_a = x[0].re
        + twiddle4.re * x118p.re
        + twiddle8.re * x217p.re
        + twiddle7.re * x316p.re
        + twiddle3.re * x415p.re
        + twiddle1.re * x514p.re
        + twiddle5.re * x613p.re
        + twiddle9.re * x712p.re
        + twiddle6.re * x811p.re
        + twiddle2.re * x910p.re;
    let b415re_b = twiddle4.im * x118n.im
        + twiddle8.im * x217n.im
        + -twiddle7.im * x316n.im
        + -twiddle3.im * x415n.im
        + twiddle1.im * x514n.im
        + twiddle5.im * x613n.im
        + twiddle9.im * x712n.im
        + -twiddle6.im * x811n.im
        + -twiddle2.im * x910n.im;
    let b514re_a = x[0].re
        + twiddle5.re * x118p.re
        + twiddle9.re * x217p.re
        + twiddle4.re * x316p.re
        + twiddle1.re * x415p.re
        + twiddle6.re * x514p.re
        + twiddle8.re * x613p.re
        + twiddle3.re * x712p.re
        + twiddle2.re * x811p.re
        + twiddle7.re * x910p.re;
    let b514re_b = twiddle5.im * x118n.im
        + -twiddle9.im * x217n.im
        + -twiddle4.im * x316n.im
        + twiddle1.im * x415n.im
        + twiddle6.im * x514n.im
        + -twiddle8.im * x613n.im
        + -twiddle3.im * x712n.im
        + twiddle2.im * x811n.im
        + twiddle7.im * x910n.im;
    let b613re_a = x[0].re
        + twiddle6.re * x118p.re
        + twiddle7.re * x217p.re
        + twiddle1.re * x316p.re
        + twiddle5.re * x415p.re
        + twiddle8.re * x514p.re
        + twiddle2.re * x613p.re
        + twiddle4.re * x712p.re
        + twiddle9.re * x811p.re
        + twiddle3.re * x910p.re;
    let b613re_b = twiddle6.im * x118n.im
        + -twiddle7.im * x217n.im
        + -twiddle1.im * x316n.im
        + twiddle5.im * x415n.im
        + -twiddle8.im * x514n.im
        + -twiddle2.im * x613n.im
        + twiddle4.im * x712n.im
        + -twiddle9.im * x811n.im
        + -twiddle3.im * x910n.im;
    let b712re_a = x[0].re
        + twiddle7.re * x118p.re
        + twiddle5.re * x217p.re
        + twiddle2.re * x316p.re
        + twiddle9.re * x415p.re
        + twiddle3.re * x514p.re
        + twiddle4.re * x613p.re
        + twiddle8.re * x712p.re
        + twiddle1.re * x811p.re
        + twiddle6.re * x910p.re;
    let b712re_b = twiddle7.im * x118n.im
        + -twiddle5.im * x217n.im
        + twiddle2.im * x316n.im
        + twiddle9.im * x415n.im
        + -twiddle3.im * x514n.im
        + twiddle4.im * x613n.im
        + -twiddle8.im * x712n.im
        + -twiddle1.im * x811n.im
        + twiddle6.im * x910n.im;
    let b811re_a = x[0].re
        + twiddle8.re * x118p.re
        + twiddle3.re * x217p.re
        + twiddle5.re * x316p.re
        + twiddle6.re * x415p.re
        + twiddle2.re * x514p.re
        + twiddle9.re * x613p.re
        + twiddle1.re * x712p.re
        + twiddle7.re * x811p.re
        + twiddle4.re * x910p.re;
    let b811re_b = twiddle8.im * x118n.im
        + -twiddle3.im * x217n.im
        + twiddle5.im * x316n.im
        + -twiddle6.im * x415n.im
        + twiddle2.im * x514n.im
        + -twiddle9.im * x613n.im
        + -twiddle1.im * x712n.im
        + twiddle7.im * x811n.im
        + -twiddle4.im * x910n.im;
    let b910re_a = x[0].re
        + twiddle9.re * x118p.re
        + twiddle1.re * x217p.re
        + twiddle8.re * x316p.re
        + twiddle2.re * x415p.re
        + twiddle7.re * x514p.re
        + twiddle3.re * x613p.re
        + twiddle6.re * x712p.re
        + twiddle4.re * x811p.re
        + twiddle5.re * x910p.re;
    let b910re_b = twiddle9.im * x118n.im
        + -twiddle1.im * x217n.im
        + twiddle8.im * x316n.im
        + -twiddle2.im * x415n.im
        + twiddle7.im * x514n.im
        + -twiddle3.im * x613n.im
        + twiddle6.im * x712n.im
        + -twiddle4.im * x811n.im
        + twiddle5.im * x910n.im;

    let b118im_a = x[0].im
        + twiddle1.re * x118p.im
        + twiddle2.re * x217p.im
        + twiddle3.re * x316p.im
        + twiddle4.re * x415p.im
        + twiddle5.re * x514p.im
        + twiddle6.re * x613p.im
        + twiddle7.re * x712p.im
        + twiddle8.re * x811p.im
        + twiddle9.re * x910p.im;
    let b118im_b = twiddle1.im * x118n.re
        + twiddle2.im * x217n.re
        + twiddle3.im * x316n.re
        + twiddle4.im * x415n.re
        + twiddle5.im * x514n.re
        + twiddle6.im * x613n.re
        + twiddle7.im * x712n.re
        + twiddle8.im * x811n.re
        + twiddle9.im * x910n.re;
    let b217im_a = x[0].im
        + twiddle2.re * x118p.im
        + twiddle4.re * x217p.im
        + twiddle6.re * x316p.im
        + twiddle8.re * x415p.im
        + twiddle9.re * x514p.im
        + twiddle7.re * x613p.im
        + twiddle5.re * x712p.im
        + twiddle3.re * x811p.im
        + twiddle1.re * x910p.im;
    let b217im_b = twiddle2.im * x118n.re
        + twiddle4.im * x217n.re
        + twiddle6.im * x316n.re
        + twiddle8.im * x415n.re
        + -twiddle9.im * x514n.re
        + -twiddle7.im * x613n.re
        + -twiddle5.im * x712n.re
        + -twiddle3.im * x811n.re
        + -twiddle1.im * x910n.re;
    let b316im_a = x[0].im
        + twiddle3.re * x118p.im
        + twiddle6.re * x217p.im
        + twiddle9.re * x316p.im
        + twiddle7.re * x415p.im
        + twiddle4.re * x514p.im
        + twiddle1.re * x613p.im
        + twiddle2.re * x712p.im
        + twiddle5.re * x811p.im
        + twiddle8.re * x910p.im;
    let b316im_b = twiddle3.im * x118n.re
        + twiddle6.im * x217n.re
        + twiddle9.im * x316n.re
        + -twiddle7.im * x415n.re
        + -twiddle4.im * x514n.re
        + -twiddle1.im * x613n.re
        + twiddle2.im * x712n.re
        + twiddle5.im * x811n.re
        + twiddle8.im * x910n.re;
    let b415im_a = x[0].im
        + twiddle4.re * x118p.im
        + twiddle8.re * x217p.im
        + twiddle7.re * x316p.im
        + twiddle3.re * x415p.im
        + twiddle1.re * x514p.im
        + twiddle5.re * x613p.im
        + twiddle9.re * x712p.im
        + twiddle6.re * x811p.im
        + twiddle2.re * x910p.im;
    let b415im_b = twiddle4.im * x118n.re
        + twiddle8.im * x217n.re
        + -twiddle7.im * x316n.re
        + -twiddle3.im * x415n.re
        + twiddle1.im * x514n.re
        + twiddle5.im * x613n.re
        + twiddle9.im * x712n.re
        + -twiddle6.im * x811n.re
        + -twiddle2.im * x910n.re;
    let b514im_a = x[0].im
        + twiddle5.re * x118p.im
        + twiddle9.re * x217p.im
        + twiddle4.re * x316p.im
        + twiddle1.re * x415p.im
        + twiddle6.re * x514p.im
        + twiddle8.re * x613p.im
        + twiddle3.re * x712p.im
        + twiddle2.re * x811p.im
        + twiddle7.re * x910p.im;
    let b514im_b = twiddle5.im * x118n.re
        + -twiddle9.im * x217n.re
        + -twiddle4.im * x316n.re
        + twiddle1.im * x415n.re
        + twiddle6.im * x514n.re
        + -twiddle8.im * x613n.re
        + -twiddle3.im * x712n.re
        + twiddle2.im * x811n.re
        + twiddle7.im * x910n.re;
    let b613im_a = x[0].im
        + twiddle6.re * x118p.im
        + twiddle7.re * x217p.im
        + twiddle1.re * x316p.im
        + twiddle5.re * x415p.im
        + twiddle8.re * x514p.im
        + twiddle2.re * x613p.im
        + twiddle4.re * x712p.im
        + twiddle9.re * x811p.im
        + twiddle3.re * x910p.im;
    let b613im_b = twiddle6.im * x118n.re
        + -twiddle7.im * x217n.re
        + -twiddle1.im * x316n.re
        + twiddle5.im * x415n.re
        + -twiddle8.im * x514n.re
        + -twiddle2.im * x613n.re
        + twiddle4.im * x712n.re
        + -twiddle9.im * x811n.re
        + -twiddle3.im * x910n.re;
    let b712im_a = x[0].im
        + twiddle7.re * x118p.im
        + twiddle5.re * x217p.im
        + twiddle2.re * x316p.im
        + twiddle9.re * x415p.im
        + twiddle3.re * x514p.im
        + twiddle4.re * x613p.im
        + twiddle8.re * x712p.im
        + twiddle1.re * x811p.im
        + twiddle6.re * x910p.im;
    let b712im_b = twiddle7.im * x118n.re
        + -twiddle5.im * x217n.re
        + twiddle2.im * x316n.re
        + twiddle9.im * x415n.re
        + -twiddle3.im * x514n.re
        + twiddle4.im * x613n.re
        + -twiddle8.im * x712n.re
        + -twiddle1.im * x811n.re
        + twiddle6.im * x910n.re;
    let b811im_a = x[0].im
        + twiddle8.re * x118p.im
        + twiddle3.re * x217p.im
        + twiddle5.re * x316p.im
        + twiddle6.re * x415p.im
        + twiddle2.re * x514p.im
        + twiddle9.re * x613p.im
        + twiddle1.re * x712p.im
        + twiddle7.re * x811p.im
        + twiddle4.re * x910p.im;
    let b811im_b = twiddle8.im * x118n.re
        + -twiddle3.im * x217n.re
        + twiddle5.im * x316n.re
        + -twiddle6.im * x415n.re
        + twiddle2.im * x514n.re
        + -twiddle9.im * x613n.re
        + -twiddle1.im * x712n.re
        + twiddle7.im * x811n.re
        + -twiddle4.im * x910n.re;
    let b910im_a = x[0].im
        + twiddle9.re * x118p.im
        + twiddle1.re * x217p.im
        + twiddle8.re * x316p.im
        + twiddle2.re * x415p.im
        + twiddle7.re * x514p.im
        + twiddle3.re * x613p.im
        + twiddle6.re * x712p.im
        + twiddle4.re * x811p.im
        + twiddle5.re * x910p.im;
    let b910im_b = twiddle9.im * x118n.re
        + -twiddle1.im * x217n.re
        + twiddle8.im * x316n.re
        + -twiddle2.im * x415n.re
        + twiddle7.im * x514n.re
        + -twiddle3.im * x613n.re
        + twiddle6.im * x712n.re
        + -twiddle4.im * x811n.re
        + twiddle5.im * x910n.re;

    let out1re = b118re_a - b118re_b;
    let out1im = b118im_a + b118im_b;
    let out2re = b217re_a - b217re_b;
    let out2im = b217im_a + b217im_b;
    let out3re = b316re_a - b316re_b;
    let out3im = b316im_a + b316im_b;
    let out4re = b415re_a - b415re_b;
    let out4im = b415im_a + b415im_b;
    let out5re = b514re_a - b514re_b;
    let out5im = b514im_a + b514im_b;
    let out6re = b613re_a - b613re_b;
    let out6im = b613im_a + b613im_b;
    let out7re = b712re_a - b712re_b;
    let out7im = b712im_a + b712im_b;
    let out8re = b811re_a - b811re_b;
    let out8im = b811im_a + b811im_b;
    let out9re = b910re_a - b910re_b;
    let out9im = b910im_a + b910im_b;
    let out10re = b910re_a + b910re_b;
    let out10im = b910im_a - b910im_b;
    let out11re = b811re_a + b811re_b;
    let out11im = b811im_a - b811im_b;
    let out12re = b712re_a + b712re_b;
    let out12im = b712im_a - b712im_b;
    let out13re = b613re_a + b613re_b;
    let out13im = b613im_a - b613im_b;
    let out14re = b514re_a + b514re_b;
    let out14im = b514im_a - b514im_b;
    let out15re = b415re_a + b415re_b;
    let out15im = b415im_a - b415im_b;
    let out16re = b316re_a + b316re_b;
    let out16im = b316im_a - b316im_b;
    let out17re = b217re_a + b217re_b;
    let out17im = b217im_a - b217im_b;
    let out18re = b118re_a + b118re_b;
    let out18im = b118im_a - b118im_b;

    [
        sum,
        Complex::new(out1re, out1im),
        Complex::new(out2re, out2im),
        Complex::new(out3re, out3im),
        Complex::new(out4re, out4im),
        Complex::new(out5re, out5im),
        Complex::new(out6re, out6im),
        Complex::new(out7re, out7im),
        Complex::new(out8re, out8im),
        Complex::new(out9re, out9im),
        Complex::new(out10re, out10im),
        Complex::new(out11re, out11im),
        Complex::new(out12re, out12im),
        Complex::new(out13re, out13im),
        Complex::new(out14re, out14im),
        Complex::new(out15re, out15im),
        Complex::new(out16re, out16im),
        Complex::new(out17re, out17im),
        Complex::new(out18re, out18im),
    ]
}

#[inline]
pub fn fft20<T: Float + FloatConst, A: AsRef<[Complex<T>]>>(input: A) -> [Complex<T>; 20] {
    let n = 20;
    let x = input.as_ref();
    assert_eq!(n, x.len());

    let row0 = fft4([x[0], x[5], x[10], x[15]]);
    let row1 = fft4([x[4], x[9], x[14], x[19]]);
    let row2 = fft4([x[8], x[13], x[18], x[3]]);
    let row3 = fft4([x[12], x[17], x[2], x[7]]);
    let row4 = fft4([x[16], x[1], x[6], x[11]]);

    let col0 = fft5([row0[0], row1[0], row2[0], row3[0], row4[0]]);
    let col1 = fft5([row0[1], row1[1], row2[1], row3[1], row4[1]]);
    let col2 = fft5([row0[2], row1[2], row2[2], row3[2], row4[2]]);
    let col3 = fft5([row0[3], row1[3], row2[3], row3[3], row4[3]]);

    [
        col0[0], col1[1], col2[2], col3[3], col0[4], col1[0], col2[1], col3[2], col0[3], col1[4],
        col2[0], col3[1], col0[2], col1[3], col2[4], col3[0], col0[1], col1[2], col2[3], col3[4],
    ]
}

#[cfg(test)]
mod tests {
    use num_complex::Complex;

    use crate::*;

    macro_rules! assert_slice_equal {
        ($lhs:expr,$rhs:expr) => {
            assert_slice_equal!($lhs, $rhs, 0.0001);
        };
        ($lhs:expr,$rhs:expr,$tol:expr) => {
            assert_eq!($lhs.len(), $rhs.len());
            for idx in 0..($lhs.len()) {
                assert!(
                    ($lhs[idx].re - $rhs[idx].re).abs() < $tol,
                    "index {} does not match: ({} - {}).abs() < {}",
                    idx,
                    $lhs[idx].re,
                    $rhs[idx].re,
                    $tol
                );
                assert!(
                    ($lhs[idx].im - $rhs[idx].im).abs() < $tol,
                    "index {} does not match: ({} - {}).abs() < {}",
                    idx,
                    $lhs[idx].im,
                    $rhs[idx].im,
                    $tol
                );
            }
        };
    }

    fn butterfly(x: Vec<Complex<f32>>) -> Vec<Complex<f32>> {
        let n = x.len();
        if n <= 1 {
            x
        } else {
            let even: Vec<_> = butterfly(x.iter().step_by(2).cloned().collect());
            let odd: Vec<_> = butterfly(x.iter().skip(1).step_by(2).cloned().collect());

            let t: Vec<_> = (0..(n / 2))
                .map(|k| {
                    Complex::exp(
                        -2.0 * Complex::<f32>::i() * std::f32::consts::PI * k as f32 / n as f32,
                    ) * odd[k]
                })
                .collect();

            [
                (0..(n / 2)).map(|k| even[k] + t[k]).collect::<Vec<_>>(),
                (0..(n / 2)).map(|k| even[k] - t[k]).collect::<Vec<_>>(),
            ]
            .concat()
        }
    }

    #[test]
    fn test_butterfly_2() {
        assert_eq!(
            fft2([Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)]).to_vec(),
            butterfly(vec![Complex::new(1.0, 0.0), Complex::new(2.0, 0.0)])
        );
    }

    #[test]
    fn test_fft3() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(3);
        let mut buf = vec![
            Complex::<f64>::new(0.0, 0.0),
            Complex::new(1.0, 0.0),
            Complex::new(2.0, 0.0),
        ];

        let monarch = fft3(&buf);

        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_butterfly_4() {
        assert_eq!(
            fft4([
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0)
            ])
            .to_vec(),
            butterfly(vec![
                Complex::new(1.0, 0.0),
                Complex::new(2.0, 0.0),
                Complex::new(3.0, 0.0),
                Complex::new(4.0, 0.0),
            ])
        );
    }

    #[test]
    fn test_fft5() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(5);
        let mut buf: Vec<_> = (0..5).map(|i| Complex::<f64>::new(i as f64, 0.0)).collect();

        let monarch = fft5(&buf);

        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft6() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(6);
        let mut buf: Vec<_> = (0..6).map(|i| Complex::<f64>::new(i as f64, 0.0)).collect();

        let monarch = fft6(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft7() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(7);
        let mut buf: Vec<_> = (0..7).map(|i| Complex::<f64>::new(i as f64, 0.0)).collect();

        let monarch = fft7(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_8() {
        let a = butterfly((1..9).map(|i| Complex::new(i as f32, 0.0)).collect());
        assert_eq!(a[0], Complex::new(36.0, 0.0));
        assert_eq!(a[6], Complex::new(-4.0, -4.0));
    }

    #[test]
    fn test_fft9() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(9);
        let mut buf: Vec<_> = (0..9).map(|i| Complex::<f64>::new(i as f64, 0.0)).collect();

        let monarch = fft9(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft10() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(10);
        let mut buf: Vec<_> = (0..10)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft10(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft11() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(11);
        let mut buf: Vec<_> = (0..11)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft11(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft12() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(12);
        let mut buf: Vec<_> = (0..12)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft12(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft13() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(13);
        let mut buf: Vec<_> = (0..13)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft13(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft14() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(14);
        let mut buf: Vec<_> = (0..14)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft14(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft15() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(15);
        let mut buf: Vec<_> = (0..15)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft15(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft17() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(17);
        let mut buf: Vec<_> = (0..17)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft17(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft18() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(18);
        let mut buf: Vec<_> = (0..18)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft18(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft19() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(19);
        let mut buf: Vec<_> = (0..19)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft19(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_fft20() {
        let mut p = rustfft::FftPlanner::new();
        let plan = p.plan_fft_forward(20);
        let mut buf: Vec<_> = (0..20)
            .map(|i| Complex::<f64>::new(i as f64, 0.0))
            .collect();

        let monarch = fft20(&buf);
        plan.process(&mut buf);

        assert_slice_equal!(monarch, buf);
    }

    #[test]
    fn test_butterfly_1024() {
        let v: Vec<_> = (0..1024)
            .map(|i: i32| Complex::new(i as f32, i as f32))
            .collect();
        let a: [Complex<f32>; 1024] = (0..1024)
            .map(|i| Complex::new(i as f32, i as f32))
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();

        let ba = fft1024(a);
        let bv = butterfly(v);

        assert_slice_equal!(ba, bv, 0.001);
    }
}
